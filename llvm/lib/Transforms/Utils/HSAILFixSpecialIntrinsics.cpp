//===--------- Fix HSAIL Special Intrinsics for Clang -------*- C++ -*-------===//
//
/// \file
/// \brief This file provides a pass to promote the "sret" parameter
/// in HSAIL special intrinsics, such as image and activelanemask
/// crosslane intrinsics, into a struct returned by value.
//
//===----------------------------------------------------------------------===//

#include "llvm/ADT/DenseMap.h"
#include "llvm/Attributes.h"
#include "llvm/DebugInfo.h"
#include "llvm/Function.h"
#include "llvm/IRBuilder.h"
#include "llvm/Module.h"

using namespace llvm;

namespace {

  /// \brief Fix prototypes for HSAIL speacial intrinsic generated by
  ///  Clang in the builtins library.
  ///
  /// The HSAIL builtins library declares each rdimage/ldimage/
  /// activelanemask intrinsic as a function that returns a struct
  /// containing the four output registers of the corresponding HSAIL
  /// instruction. But the SPIR calling convention in Clang translates
  /// this return type to an"sret" pointer as the first parameter to the
  /// function. This pass fixes the prototypes in LLVM IR to return the
  /// original struct by value instead of the "sret" parameter.
  ///
  /// This pass is meant to be used only when compiling the image
  /// builtins/activelanemask builtins in the HSAIL builtins library. It is
  /// not meant as a general purpose transformation, and especially
  /// not meant to be used in the online compiler flow. Having this
  /// transformation as a standalone pre-opt pass allows us to fix the
  /// output from EDG/clc as well as Clang/clc2.
  class HSAILFixSpecialIntrinsics : public ModulePass {
  public:
    static char ID;
    explicit HSAILFixSpecialIntrinsics() : ModulePass(ID) {};

  private:
    virtual bool runOnModule(Module &M);
  };

  /// Map a function to corresponding debug info.
  typedef DenseMap<Function*, DISubprogram> FunctionDIMap;

} // end anonymous namespace

char HSAILFixSpecialIntrinsics::ID = 0;

INITIALIZE_PASS(HSAILFixSpecialIntrinsics,
                "amd-fix-hsail-special-intrinsics",
                "Fix HSAIL speacial intrinsics (only for the builtins library)",
                false, false)

/// \brief Map each function in the module to its debug info
///
/// This function was copied directly from the DAE pass in LLVM 3.2
static void collectFunctionDIs(FunctionDIMap &FunctionDIs, Module &M)
{
  FunctionDIs.clear();

  for (Module::named_metadata_iterator I = M.named_metadata_begin(),
       E = M.named_metadata_end(); I != E; ++I) {
    NamedMDNode &NMD = *I;
    for (unsigned MDIndex = 0, MDNum = NMD.getNumOperands();
         MDIndex < MDNum; ++MDIndex) {
      MDNode *Node = NMD.getOperand(MDIndex);
      if (!DIDescriptor(Node).isCompileUnit())
        continue;
      DICompileUnit CU(Node);
      const DIArray &SPs = CU.getSubprograms();
      for (unsigned SPIndex = 0, SPNum = SPs.getNumElements();
           SPIndex < SPNum; ++SPIndex) {
        DISubprogram SP(SPs.getElement(SPIndex));
        if (!SP.Verify())
          continue;
        if (Function *F = SP.getFunction())
          FunctionDIs[F] = SP;
      }
    }
  }
}

/// \brief Call the new intrinsic where the original intrinsic was called.
///
/// The new call returns the structure by value. We store this value
/// into the allocation used by the original call. The old call must
/// be deleted by the caller; the allocation will be optimized away by
/// a subsequent mem2reg.
static void createNewCall(Function *F, Function *NewF, CallInst *Call) {
  IRBuilder<> IB(Call);

  AllocaInst *SretAlloca = cast<AllocaInst>(Call->getOperand(0));
  unsigned alignment = SretAlloca->getAlignment();

  // The original intrinsic has at most four arguments for rdimage/ldimage:
  //    (sret, image, [sampler,] coords)
  // And activelanmask intrinsic has two arguments:
  //    (sret, src)
  // Of these, we will drop the first arg.
  SmallVector<Value*, 3> Args;
  for (unsigned i = 1, e = Call->getNumArgOperands(); i != e; ++i)
    Args.push_back(Call->getArgOperand(i));

  CallInst *NewCall = IB.CreateCall(NewF, Args);
  Value *Ptr = IB.CreateConstGEP1_32(SretAlloca, 0);
  StoreInst *Store = IB.CreateAlignedStore(NewCall, Ptr, alignment);
}

/// \brief Replace all uses of the old intrinsic with the new one.
static void replaceUses(Function *F, Function *NewF) {
  while (!F->use_empty()) {
    CallInst *Call = cast<CallInst>(F->use_back());
    createNewCall(F, NewF, Call);
    Call->eraseFromParent();
  }
}

/// \brief Copy function attributes.
static void copyFnAttributes(Function *From, Function *To) {
  const Attributes FnA = From->getFnAttributes();
  AttrListPtr NewA;
  NewA = NewA.addAttr(From->getContext(), AttrListPtr::FunctionIndex, FnA);
  To->setAttributes(NewA);
}

/// \brief Create a new intrinsic that returns a struct instead of an
/// sret parameter.
static Function* createNewIntrinsic(Function *F) {
  FunctionType *FType = F->getFunctionType();

  PointerType *PType = cast<PointerType>(FType->getParamType(0));
  StructType *SType = cast<StructType>(PType->getElementType());

  // The original intrinsic has at most four arguments for rdimage/ldimage:
  //    (sret, image, [sampler,] coords)
  // And activelanmask intrinsic has two arguments:
  //    (sret, src)
  // Of these, we will drop the first arg.
  SmallVector<Type*, 3> ArgTypes;
  ArgTypes.append(FType->param_begin() + 1, FType->param_end());

  FunctionType *NewFType = FunctionType::get(SType, ArgTypes, false);

  // Create new function, but don't insert in module.
  Function *NewF = Function::Create(NewFType, F->getLinkage());
  NewF->takeName(F);

  // Just get the Fn attributes. We don't need the rest.
  copyFnAttributes(F, NewF);

  return NewF;
}

bool HSAILFixSpecialIntrinsics::runOnModule(Module &M) {
  bool changed = false;
  FunctionDIMap FunctionDIs;
  collectFunctionDIs(FunctionDIs, M);

  // Iterate over the ilist a little differently since we will replace
  // some members along the way.
  for (Module::iterator II = M.begin(), IE = M.end();
       II != IE;) {
    Function *F = II++; // Note the post-increment operator
    StringRef Name = F->getName();

	// For image2D depth the HSAIL intrinsic returns scalar(float) and not
	// struct
	if (Name.startswith("__hsail_rdimagef_2ddepth")
		|| Name.startswith("__hsail_ldimagef_2ddepth")
		  || Name.startswith("__hsail_rdimagef_2dadepth")
		    || Name.startswith("__hsail_ldimagef_2dadepth"))
	  continue;
    if (!Name.startswith("__hsail_ldimage")
        && !Name.startswith("__hsail_rdimage") &&
        !Name.startswith("__hsail_activelanemask"))
      continue;
    changed = true;

    assert(F->empty());
    assert(F->hasStructRetAttr());

    Function *NewF = createNewIntrinsic(F);
    replaceUses(F, NewF);

    // Replace the function pointer in the debug info descriptor.
    //
    // TODO: It is not clear whether debug info is provided for
    // library functions.
    FunctionDIMap::iterator DI = FunctionDIs.find(F);
    if (DI != FunctionDIs.end())
      DI->second.replaceFunction(NewF);

    M.getFunctionList().insert(F, NewF); // Insert before F
    F->eraseFromParent();
  }

  return changed;
}
