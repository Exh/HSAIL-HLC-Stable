using Microsoft.Build.CPPTasks;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Resources;

namespace AMD.Build.AACLTasks
{
    public class AACL : TrackedVCToolTask
    {
        private ArrayList switchOrderList;
        private ITaskItem[] preprocessOutput = new ITaskItem[0];
        private string[] objectFiles;
        private string[] browseInformationFiles;
        private string[] xmlDocumentationFiles;
        private Dictionary<string, ITaskItem> trackedInputFilesToRemove;
        private Dictionary<string, ITaskItem> trackedOutputFilesToRemove;
        protected override string ToolName
        {
            get
            {
                return "AACL.exe";
            }
        }
        protected override string AlwaysAppend
        {
            get
            {
                return "/c";
            }
        }
        public virtual string[] AdditionalIncludeDirectories
        {
            get
            {
                if (base.IsPropertySet("AdditionalIncludeDirectories"))
                {
                    return base.ActiveToolSwitches["AdditionalIncludeDirectories"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AdditionalIncludeDirectories");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Additional Include Directories";
                toolSwitch.Description = "Specifies one or more directories to add to the include path; separate with semi-colons if more than one.     (/I[path])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/I";
                toolSwitch.Name = "AdditionalIncludeDirectories";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AdditionalIncludeDirectories", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] AdditionalUsingDirectories
        {
            get
            {
                if (base.IsPropertySet("AdditionalUsingDirectories"))
                {
                    return base.ActiveToolSwitches["AdditionalUsingDirectories"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AdditionalUsingDirectories");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Resolve #using References";
                toolSwitch.Description = "Specifies one or more directories (separate directory names with a semicolon) to be searched to resolve names passed to a #using directive.  (/AI[path])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/AI";
                toolSwitch.Name = "AdditionalUsingDirectories";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AdditionalUsingDirectories", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string DebugInformationFormat
        {
            get
            {
                if (base.IsPropertySet("DebugInformationFormat"))
                {
                    return base.ActiveToolSwitches["DebugInformationFormat"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("DebugInformationFormat");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Debug Information Format";
                toolSwitch.Description = "Specifies the type of debugging information generated by the compiler.  You must also change linker settings appropriately to match.    (/Z7, Zd, /Zi, /ZI)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "OldStyle", 
                        "/Z7"
                    }, 
                    new string[]
                    {
                        "ProgramDatabase", 
                        "/Zi"
                    }, 
                    new string[]
                    {
                        "EditAndContinue", 
                        "/ZI"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("DebugInformationFormat", switchMap, value);
                toolSwitch.Name = "DebugInformationFormat";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("DebugInformationFormat", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string CompileAsManaged
        {
            get
            {
                if (base.IsPropertySet("CompileAsManaged"))
                {
                    return base.ActiveToolSwitches["CompileAsManaged"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CompileAsManaged");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Common Language RunTime Support";
                toolSwitch.Description = "Use the .NET runtime service.  This switch is incompatible with some other switches; see the documentation on the /clr family of switches for details.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "false", 
                        ""
                    }, 
                    new string[]
                    {
                        "true", 
                        "/clr"
                    }, 
                    new string[]
                    {
                        "Pure", 
                        "/clr:pure"
                    }, 
                    new string[]
                    {
                        "Safe", 
                        "/clr:safe"
                    }, 
                    new string[]
                    {
                        "OldSyntax", 
                        "/clr:oldSyntax"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CompileAsManaged", switchMap, value);
                toolSwitch.Name = "CompileAsManaged";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CompileAsManaged", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool SuppressStartupBanner
        {
            get
            {
                return base.IsPropertySet("SuppressStartupBanner") && base.ActiveToolSwitches["SuppressStartupBanner"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SuppressStartupBanner");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Suppress Startup Banner";
                toolSwitch.Description = "Suppresses the display of the sign-on banner when the compiler starts up and display of informational messages during compiling.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/nologo";
                toolSwitch.ReverseSwitchValue = "/nologo-";
                toolSwitch.Name = "SuppressStartupBanner";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SuppressStartupBanner", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("nologo", "nologo-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("nologo-", "nologo"));
            }
        }
        public virtual string WarningLevel
        {
            get
            {
                if (base.IsPropertySet("WarningLevel"))
                {
                    return base.ActiveToolSwitches["WarningLevel"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("WarningLevel");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Warning Level";
                toolSwitch.Description = "Select how strict you want the compiler to be about code errors.     (/W0 - /W4)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "TurnOffAllWarnings", 
                        "/W0"
                    }, 
                    new string[]
                    {
                        "Level1", 
                        "/W1"
                    }, 
                    new string[]
                    {
                        "Level2", 
                        "/W2"
                    }, 
                    new string[]
                    {
                        "Level3", 
                        "/W3"
                    }, 
                    new string[]
                    {
                        "Level4", 
                        "/W4"
                    }, 
                    new string[]
                    {
                        "EnableAllWarnings", 
                        "/Wall"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("WarningLevel", switchMap, value);
                toolSwitch.Name = "WarningLevel";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("WarningLevel", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool TreatWarningAsError
        {
            get
            {
                return base.IsPropertySet("TreatWarningAsError") && base.ActiveToolSwitches["TreatWarningAsError"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TreatWarningAsError");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Treat Warnings As Errors";
                toolSwitch.Description = "Treats all compiler warnings as errors. For a new project, it may be best to use /WX in all compilations; resolving all warnings will ensure the fewest possible hard-to-find code defects.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/WX";
                toolSwitch.ReverseSwitchValue = "/WX-";
                toolSwitch.Name = "TreatWarningAsError";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("TreatWarningAsError", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("WX", "WX-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("WX-", "WX"));
            }
        }
        public virtual string TrackerLogDirectory
        {
            get
            {
                if (base.IsPropertySet("TrackerLogDirectory"))
                {
                    return base.ActiveToolSwitches["TrackerLogDirectory"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TrackerLogDirectory");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Directory);
                toolSwitch.DisplayName = "Tracker Log Directory";
                toolSwitch.Description = "Tracker Log Directory.";
               toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Value = VCToolTask.EnsureTrailingSlash(value);
                base.ActiveToolSwitches.Add("TrackerLogDirectory", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool MultiProcessorCompilation
        {
            get
            {
                return base.IsPropertySet("MultiProcessorCompilation") && base.ActiveToolSwitches["MultiProcessorCompilation"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MultiProcessorCompilation");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Multi-processor Compilation";
                toolSwitch.Description = "Multi-processor Compilation";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("ProcessorNumber", "true", false, ""));
                toolSwitch.SwitchValue = "/MP";
                toolSwitch.Name = "MultiProcessorCompilation";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("MultiProcessorCompilation", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool KeepIntermediateFiles
        {
            get
            {
                return base.IsPropertySet("KeepIntermediateFiles") && base.ActiveToolSwitches["KeepIntermediateFiles"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("KeepIntermediateFiles");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Keep Intermediate Files";
                toolSwitch.Description = "Disables deletion of AMD specific intermediate files.    (/keeptmp)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/keeptmp";
                toolSwitch.Name = "KeepIntermediateFiles";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("KeepIntermediateFiles", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string Optimization
        {
            get
            {
                if (base.IsPropertySet("Optimization"))
                {
                    return base.ActiveToolSwitches["Optimization"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("Optimization");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Optimization";
                toolSwitch.Description = "Select option for code optimization; choose Custom to use specific optimization options.     (/Od, /O1, /O2, /Ox)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Disabled", 
                        "/Od"
                    }, 
                    new string[]
                    {
                        "MinSpace", 
                        "/O1"
                    }, 
                    new string[]
                    {
                        "MaxSpeed", 
                        "/O2"
                    }, 
                    new string[]
                    {
                        "Full", 
                        "/Ox"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("Optimization", switchMap, value);
                toolSwitch.Name = "Optimization";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("Optimization", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string InlineFunctionExpansion
        {
            get
            {
                if (base.IsPropertySet("InlineFunctionExpansion"))
                {
                    return base.ActiveToolSwitches["InlineFunctionExpansion"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("InlineFunctionExpansion");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Inline Function Expansion";
                toolSwitch.Description = "Select the level of inline function expansion for the build.     (/Ob1, /Ob2)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Default", 
                        ""
                    }, 
                    new string[]
                    {
                        "Disabled", 
                        "/Ob0"
                    }, 
                    new string[]
                    {
                        "OnlyExplicitInline", 
                        "/Ob1"
                    }, 
                    new string[]
                    {
                        "AnySuitable", 
                        "/Ob2"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("InlineFunctionExpansion", switchMap, value);
                toolSwitch.Name = "InlineFunctionExpansion";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("InlineFunctionExpansion", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool IntrinsicFunctions
        {
            get
            {
                return base.IsPropertySet("IntrinsicFunctions") && base.ActiveToolSwitches["IntrinsicFunctions"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("IntrinsicFunctions");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Intrinsic Functions";
                toolSwitch.Description = "Enables intrinsic functions.  Using intrinsic functions generates faster, but possibly larger, code.     (/Oi)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Oi";
                toolSwitch.Name = "IntrinsicFunctions";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("IntrinsicFunctions", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Oi", "Oi-"));
            }
        }
        public virtual string FavorSizeOrSpeed
        {
            get
            {
                if (base.IsPropertySet("FavorSizeOrSpeed"))
                {
                    return base.ActiveToolSwitches["FavorSizeOrSpeed"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("FavorSizeOrSpeed");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Favor Size Or Speed";
                toolSwitch.Description = "Whether to favor code size or code speed; 'Global Optimization' must be turned on.     (/Ot, /Os)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Size", 
                        "/Os"
                    }, 
                    new string[]
                    {
                        "Speed", 
                        "/Ot"
                    }, 
                    new string[]
                    {
                        "Neither", 
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("FavorSizeOrSpeed", switchMap, value);
                toolSwitch.Name = "FavorSizeOrSpeed";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("FavorSizeOrSpeed", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool OmitFramePointers
        {
            get
            {
                return base.IsPropertySet("OmitFramePointers") && base.ActiveToolSwitches["OmitFramePointers"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("OmitFramePointers");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Omit Frame Pointers";
                toolSwitch.Description = "Suppresses creation of frame pointers on the call stack.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Oy";
                toolSwitch.ReverseSwitchValue = "/Oy-";
                toolSwitch.Name = "OmitFramePointers";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("OmitFramePointers", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Oy", "Oy-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Oy-", "Oy"));
            }
        }
        public virtual bool EnableFiberSafeOptimizations
        {
            get
            {
                return base.IsPropertySet("EnableFiberSafeOptimizations") && base.ActiveToolSwitches["EnableFiberSafeOptimizations"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EnableFiberSafeOptimizations");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Fiber-Safe Optimizations";
                toolSwitch.Description = "Enables memory space optimization when using fibers and thread local storage access.     (/GT)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/GT";
                toolSwitch.Name = "EnableFiberSafeOptimizations";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("EnableFiberSafeOptimizations", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool WholeProgramOptimization
        {
            get
            {
                return base.IsPropertySet("WholeProgramOptimization") && base.ActiveToolSwitches["WholeProgramOptimization"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("WholeProgramOptimization");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Whole Program Optimization";
                toolSwitch.Description = "Enables cross-module optimizations by delaying code generation to link time; requires that linker option 'Link Time Code Generation' be turned on.     (/GL)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/GL";
                toolSwitch.Name = "WholeProgramOptimization";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("WholeProgramOptimization", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] PreprocessorDefinitions
        {
            get
            {
                if (base.IsPropertySet("PreprocessorDefinitions"))
                {
                    return base.ActiveToolSwitches["PreprocessorDefinitions"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PreprocessorDefinitions");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Preprocessor Definitions";
                toolSwitch.Description = "Defines a preprocessing symbols for your source file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/D ";
                toolSwitch.Name = "PreprocessorDefinitions";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("PreprocessorDefinitions", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] UndefinePreprocessorDefinitions
        {
            get
            {
                if (base.IsPropertySet("UndefinePreprocessorDefinitions"))
                {
                    return base.ActiveToolSwitches["UndefinePreprocessorDefinitions"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UndefinePreprocessorDefinitions");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Undefine Preprocessor Definitions";
                toolSwitch.Description = "Specifies one or more preprocessor undefines.     (/U[macro])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/U";
                toolSwitch.Name = "UndefinePreprocessorDefinitions";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("UndefinePreprocessorDefinitions", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool UndefineAllPreprocessorDefinitions
        {
            get
            {
                return base.IsPropertySet("UndefineAllPreprocessorDefinitions") && base.ActiveToolSwitches["UndefineAllPreprocessorDefinitions"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UndefineAllPreprocessorDefinitions");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Undefine All Preprocessor Definitions";
                toolSwitch.Description = "Undefine all previously defined preprocessor values.     (/u)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/u";
                toolSwitch.Name = "UndefineAllPreprocessorDefinitions";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("UndefineAllPreprocessorDefinitions", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool IgnoreStandardIncludePath
        {
            get
            {
                return base.IsPropertySet("IgnoreStandardIncludePath") && base.ActiveToolSwitches["IgnoreStandardIncludePath"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("IgnoreStandardIncludePath");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Ignore Standard Include Paths";
                toolSwitch.Description = "Prevents the compiler from searching for include files in directories specified in the INCLUDE environment variables.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/X";
                toolSwitch.Name = "IgnoreStandardIncludePath";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("IgnoreStandardIncludePath", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool PreprocessToFile
        {
            get
            {
                return base.IsPropertySet("PreprocessToFile") && base.ActiveToolSwitches["PreprocessToFile"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PreprocessToFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Preprocess to a File";
                toolSwitch.Description = "Preprocesses C and C++ source files and writes the preprocessed output to a file. This option suppresses compilation, thus it does not produce an .obj file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/P";
                toolSwitch.Name = "PreprocessToFile";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("PreprocessToFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string PreprocessOutputPath
        {
            get
            {
                if (base.IsPropertySet("PreprocessOutputPath"))
                {
                    return base.ActiveToolSwitches["PreprocessOutputPath"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PreprocessOutputPath");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Preprocess Output Path";
                toolSwitch.Description = "Specify the output path for the preprocesser. The default location is the same as the source file(s).";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "PreprocessOutputPath";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/Fi";
                base.ActiveToolSwitches.Add("PreprocessOutputPath", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool PreprocessSuppressLineNumbers
        {
            get
            {
                return base.IsPropertySet("PreprocessSuppressLineNumbers") && base.ActiveToolSwitches["PreprocessSuppressLineNumbers"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PreprocessSuppressLineNumbers");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Preprocess Suppress Line Numbers";
                toolSwitch.Description = "Preprocess without #line directives.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/EP";
                toolSwitch.Name = "PreprocessSuppressLineNumbers";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("PreprocessSuppressLineNumbers", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool PreprocessKeepComments
        {
            get
            {
                return base.IsPropertySet("PreprocessKeepComments") && base.ActiveToolSwitches["PreprocessKeepComments"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PreprocessKeepComments");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Keep Comments";
                toolSwitch.Description = "Suppresses comment strip from source code; requires that one of the 'Preprocessing' options be set.     (/C)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/C";
                toolSwitch.Name = "PreprocessKeepComments";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("PreprocessKeepComments", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool StringPooling
        {
            get
            {
                return base.IsPropertySet("StringPooling") && base.ActiveToolSwitches["StringPooling"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("StringPooling");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable String Pooling";
                toolSwitch.Description = "Enables the compiler to create a single read-only copy of identical strings in the program image and in memory during execution, resulting in smaller programs, an optimization called string pooling. /O1, /O2, and /ZI  automatically set /GF option. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/GF";
                toolSwitch.ReverseSwitchValue = "/GF-";
                toolSwitch.Name = "StringPooling";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("StringPooling", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GF", "GF-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GF-", "GF"));
            }
        }
        public virtual bool MinimalRebuild
        {
            get
            {
                return base.IsPropertySet("MinimalRebuild") && base.ActiveToolSwitches["MinimalRebuild"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MinimalRebuild");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Minimal Rebuild";
                toolSwitch.Description = "Enables minimal rebuild, which determines whether C++ source files that include changed C++ class definitions (stored in header (.h) files) need to be recompiled.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Gm";
                toolSwitch.ReverseSwitchValue = "/Gm-";
                toolSwitch.Name = "MinimalRebuild";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("MinimalRebuild", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Gm", "Gm-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Gm-", "Gm"));
            }
        }
        public virtual string ExceptionHandling
        {
            get
            {
                if (base.IsPropertySet("ExceptionHandling"))
                {
                    return base.ActiveToolSwitches["ExceptionHandling"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ExceptionHandling");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Enable C++ Exceptions";
                toolSwitch.Description = "Specifies the model of exception handling to be used by the compiler.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Async", 
                        "/EHa"
                    }, 
                    new string[]
                    {
                        "Sync", 
                        "/EHsc"
                    }, 
                    new string[]
                    {
                        "SyncCThrow", 
                        "/EHs"
                    }, 
                    new string[]
                    {
                        "false", 
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("ExceptionHandling", switchMap, value);
                toolSwitch.Name = "ExceptionHandling";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("ExceptionHandling", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool SmallerTypeCheck
        {
            get
            {
                return base.IsPropertySet("SmallerTypeCheck") && base.ActiveToolSwitches["SmallerTypeCheck"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SmallerTypeCheck");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Smaller Type Check";
                toolSwitch.Description = "Enable checking for conversion to smaller types, incompatible with any optimization type other than debug.     (/RTCc)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/RTCc";
                toolSwitch.Name = "SmallerTypeCheck";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SmallerTypeCheck", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string BasicRuntimeChecks
        {
            get
            {
                if (base.IsPropertySet("BasicRuntimeChecks"))
                {
                    return base.ActiveToolSwitches["BasicRuntimeChecks"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BasicRuntimeChecks");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Basic Runtime Checks";
                toolSwitch.Description = "Perform basic runtime error checks, incompatible with any optimization type other than debug.     (/RTCs, /RTCu, /RTC1)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "StackFrameRuntimeCheck", 
                        "/RTCs"
                    }, 
                    new string[]
                    {
                        "UninitializedLocalUsageCheck", 
                        "/RTCu"
                    }, 
                    new string[]
                    {
                        "EnableFastChecks", 
                        "/RTC1"
                    }, 
                    new string[]
                    {
                        "Default", 
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("BasicRuntimeChecks", switchMap, value);
                toolSwitch.Name = "BasicRuntimeChecks";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("BasicRuntimeChecks", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string RuntimeLibrary
        {
            get
            {
                if (base.IsPropertySet("RuntimeLibrary"))
                {
                    return base.ActiveToolSwitches["RuntimeLibrary"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("RuntimeLibrary");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Runtime Library";
                toolSwitch.Description = "Specify runtime library for linking.     (/MT, /MTd, /MD, /MDd)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "MultiThreaded", 
                        "/MT"
                    }, 
                    new string[]
                    {
                        "MultiThreadedDebug", 
                        "/MTd"
                    }, 
                    new string[]
                    {
                        "MultiThreadedDLL", 
                        "/MD"
                    }, 
                    new string[]
                    {
                        "MultiThreadedDebugDLL", 
                        "/MDd"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("RuntimeLibrary", switchMap, value);
                toolSwitch.Name = "RuntimeLibrary";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("RuntimeLibrary", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string StructMemberAlignment
        {
            get
            {
                if (base.IsPropertySet("StructMemberAlignment"))
                {
                    return base.ActiveToolSwitches["StructMemberAlignment"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("StructMemberAlignment");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Struct Member Alignment";
                toolSwitch.Description = "Specifies 1, 2, 4, or 8-byte boundaries for struct member alignment.     (/Zp[num])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "1Byte", 
                        "/Zp1"
                    }, 
                    new string[]
                    {
                        "2Bytes", 
                        "/Zp2"
                    }, 
                    new string[]
                    {
                        "4Bytes", 
                        "/Zp4"
                    }, 
                    new string[]
                    {
                        "8Bytes", 
                        "/Zp8"
                    }, 
                    new string[]
                    {
                        "16Bytes", 
                        "/Zp16"
                    }, 
                    new string[]
                    {
                        "Default", 
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("StructMemberAlignment", switchMap, value);
                toolSwitch.Name = "StructMemberAlignment";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("StructMemberAlignment", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool BufferSecurityCheck
        {
            get
            {
                return base.IsPropertySet("BufferSecurityCheck") && base.ActiveToolSwitches["BufferSecurityCheck"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BufferSecurityCheck");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Buffer Security Check";
                toolSwitch.Description = "Check for buffer overruns; useful for closing hackable loopholes on internet servers.  The default is enabled.     (/GS-)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/GS";
                toolSwitch.ReverseSwitchValue = "/GS-";
                toolSwitch.Name = "BufferSecurityCheck";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("BufferSecurityCheck", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GS", "GS-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GS-", "GS"));
            }
        }
        public virtual bool FunctionLevelLinking
        {
            get
            {
                return base.IsPropertySet("FunctionLevelLinking") && base.ActiveToolSwitches["FunctionLevelLinking"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("FunctionLevelLinking");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Function-Level Linking";
                toolSwitch.Description = "Allows the compiler to package individual functions in the form of packaged functions (COMDATs). Required for edit and continue to work.     (/Gy)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Gy";
                toolSwitch.ReverseSwitchValue = "/Gy-";
                toolSwitch.Name = "FunctionLevelLinking";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("FunctionLevelLinking", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Gy", "Gy-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Gy-", "Gy"));
            }
        }
        public virtual string EnableEnhancedInstructionSet
        {
            get
            {
                if (base.IsPropertySet("EnableEnhancedInstructionSet"))
                {
                    return base.ActiveToolSwitches["EnableEnhancedInstructionSet"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EnableEnhancedInstructionSet");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Enable Enhanced Instruction Set";
                toolSwitch.Description = "Enable use of instructions found on processors that support enhanced instruction sets, e.g., the SSE and SSE2 enhancements to the IA-32. Currently only available when building for the x86 architecture.   (/arch:SSE, /arch:SSE2)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "StreamingSIMDExtensions", 
                        "/arch:SSE"
                    }, 
                    new string[]
                    {
                        "StreamingSIMDExtensions2", 
                        "/arch:SSE2"
                    }, 
                    new string[]
                    {
                        "NotSet", 
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("EnableEnhancedInstructionSet", switchMap, value);
                toolSwitch.Name = "EnableEnhancedInstructionSet";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("EnableEnhancedInstructionSet", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string FloatingPointModel
        {
            get
            {
                if (base.IsPropertySet("FloatingPointModel"))
                {
                    return base.ActiveToolSwitches["FloatingPointModel"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("FloatingPointModel");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Floating Point Model";
                toolSwitch.Description = "Sets the floating point model.     (/fp:precise, /fp:strict, /fp:fast)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Precise", 
                        "/fp:precise"
                    }, 
                    new string[]
                    {
                        "Strict", 
                        "/fp:strict"
                    }, 
                    new string[]
                    {
                        "Fast", 
                        "/fp:fast"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("FloatingPointModel", switchMap, value);
                toolSwitch.Name = "FloatingPointModel";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("FloatingPointModel", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool FloatingPointExceptions
        {
            get
            {
                return base.IsPropertySet("FloatingPointExceptions") && base.ActiveToolSwitches["FloatingPointExceptions"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("FloatingPointExceptions");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Floating Point Exceptions";
                toolSwitch.Description = "Reliable floating-point exception model. Exceptions will be raised immediately after they are triggered.      (/fp:except)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/fp:except";
                toolSwitch.ReverseSwitchValue = "/fp:except-";
                toolSwitch.Name = "FloatingPointExceptions";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("FloatingPointExceptions", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("fp:except", "fp:except-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("fp:except-", "fp:except"));
            }
        }
        public virtual bool CreateHotpatchableImage
        {
            get
            {
                return base.IsPropertySet("CreateHotpatchableImage") && base.ActiveToolSwitches["CreateHotpatchableImage"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CreateHotpatchableImage");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Create Hotpatchable Image";
                toolSwitch.Description = "When hotpatching is on, the compiler ensures that first instruction of each function is two bytes, which is required for hot patching.  (/hotpatch)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/hotpatch";
                toolSwitch.Name = "CreateHotpatchableImage";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("CreateHotpatchableImage", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool DisableLanguageExtensions
        {
            get
            {
                return base.IsPropertySet("DisableLanguageExtensions") && base.ActiveToolSwitches["DisableLanguageExtensions"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("DisableLanguageExtensions");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Disable Language Extensions";
                toolSwitch.Description = "Suppresses or enables language extensions.     (/Za)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Za";
                toolSwitch.Name = "DisableLanguageExtensions";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("DisableLanguageExtensions", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool TreatWChar_tAsBuiltInType
        {
            get
            {
                return base.IsPropertySet("TreatWChar_tAsBuiltInType") && base.ActiveToolSwitches["TreatWChar_tAsBuiltInType"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TreatWChar_tAsBuiltInType");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Treat WChar_t As Built in Type";
                toolSwitch.Description = "When specified, the type wchar_t becomes a native type that maps to __wchar_t in the same way that short maps to __int16. /Zc:wchar_t is on by default.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Zc:wchar_t";
                toolSwitch.ReverseSwitchValue = "/Zc:wchar_t-";
                toolSwitch.Name = "TreatWChar_tAsBuiltInType";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("TreatWChar_tAsBuiltInType", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Zc:wchar_t", "Zc:wchar_t-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Zc:wchar_t-", "Zc:wchar_t"));
            }
        }
        public virtual bool ForceConformanceInForLoopScope
        {
            get
            {
                return base.IsPropertySet("ForceConformanceInForLoopScope") && base.ActiveToolSwitches["ForceConformanceInForLoopScope"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ForceConformanceInForLoopScope");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Force Conformance in For Loop Scope";
                toolSwitch.Description = "Used to implement standard C++ behavior for the for statement loops with Microsoft extensions (/Za, /Ze (Disable Language Extensions)). /Zc:forScope is on by default.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Zc:forScope";
                toolSwitch.ReverseSwitchValue = "/Zc:forScope-";
                toolSwitch.Name = "ForceConformanceInForLoopScope";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("ForceConformanceInForLoopScope", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Zc:forScope", "Zc:forScope-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Zc:forScope-", "Zc:forScope"));
            }
        }
        public virtual bool RuntimeTypeInfo
        {
            get
            {
                return base.IsPropertySet("RuntimeTypeInfo") && base.ActiveToolSwitches["RuntimeTypeInfo"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("RuntimeTypeInfo");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Run-Time Type Information";
                toolSwitch.Description = "Adds code for checking C++ object types at run time (runtime type information).     (/GR, /GR-)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/GR";
                toolSwitch.ReverseSwitchValue = "/GR-";
                toolSwitch.Name = "RuntimeTypeInfo";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("RuntimeTypeInfo", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GR", "GR-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GR-", "GR"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("GR-", "D"));
            }
        }
        public virtual bool OpenMPSupport
        {
            get
            {
                return base.IsPropertySet("OpenMPSupport") && base.ActiveToolSwitches["OpenMPSupport"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("OpenMPSupport");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Open MP Support";
                toolSwitch.Description = "Enable OpenMP 2.0 language extensions.     (/openmp)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/openmp";
                toolSwitch.ReverseSwitchValue = "/openmp-";
                toolSwitch.Name = "OpenMPSupport";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("OpenMPSupport", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("openmp", "openmp-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("openmp-", "openmp"));
            }
        }
        public virtual string PrecompiledHeader
        {
            get
            {
                if (base.IsPropertySet("PrecompiledHeader"))
                {
                    return base.ActiveToolSwitches["PrecompiledHeader"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PrecompiledHeader");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Precompiled Header";
                toolSwitch.Description = "Create/Use Precompiled Header : Enables creation or use of a precompiled header during the build.     (/Yc, /Yu)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("PrecompiledHeaderFile", "Create", false, ""));
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("PrecompiledHeaderFile", "Use", false, ""));
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Create", 
                        "/Yc"
                    }, 
                    new string[]
                    {
                        "Use", 
                        "/Yu"
                    }, 
                    new string[]
                    {
                        "NotUsing", 
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("PrecompiledHeader", switchMap, value);
                toolSwitch.Name = "PrecompiledHeader";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("PrecompiledHeader", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string PrecompiledHeaderOutputFile
        {
            get
            {
                if (base.IsPropertySet("PrecompiledHeaderOutputFile"))
                {
                    return base.ActiveToolSwitches["PrecompiledHeaderOutputFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PrecompiledHeaderOutputFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "Precompiled Header Output File";
                toolSwitch.Description = "Specifies the path and/or name of the generated precompiled header file. (/Fp[name])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Fp";
                toolSwitch.Name = "PrecompiledHeaderOutputFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("PrecompiledHeaderOutputFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Fp", "Fp-"));
            }
        }
        public virtual bool ExpandAttributedSource
        {
            get
            {
                return base.IsPropertySet("ExpandAttributedSource") && base.ActiveToolSwitches["ExpandAttributedSource"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ExpandAttributedSource");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Expand Attributed Source";
                toolSwitch.Description = "Create listing file with expanded attributes injected into source file.     (/Fx)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Fx";
                toolSwitch.Name = "ExpandAttributedSource";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("ExpandAttributedSource", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string AssemblerOutput
        {
            get
            {
                if (base.IsPropertySet("AssemblerOutput"))
                {
                    return base.ActiveToolSwitches["AssemblerOutput"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AssemblerOutput");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Assembler Output";
                toolSwitch.Description = "Specifies the contents of assembly language output file.     (/FA, /FAc, /FAs, /FAcs)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "NoListing", 
                        ""
                    }, 
                    new string[]
                    {
                        "AssemblyCode", 
                        "/FA"
                    }, 
                    new string[]
                    {
                        "AssemblyAndMachineCode", 
                        "/FAc"
                    }, 
                    new string[]
                    {
                        "AssemblyAndSourceCode", 
                        "/FAs"
                    }, 
                    new string[]
                    {
                        "All", 
                        "/FAcs"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("AssemblerOutput", switchMap, value);
                toolSwitch.Name = "AssemblerOutput";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("AssemblerOutput", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string AssemblerListingLocation
        {
            get
            {
                if (base.IsPropertySet("AssemblerListingLocation"))
                {
                    return base.ActiveToolSwitches["AssemblerListingLocation"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AssemblerListingLocation");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "ASM List Location";
                toolSwitch.Description = "Specifies relative path and/or name for ASM listing file; can be file or directory name.     (/Fa[name])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Fa";
                toolSwitch.Name = "AssemblerListingLocation";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("AssemblerListingLocation", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Fa", "bA"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Fa", "bo"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Fa", "Fa"));
            }
        }
        public virtual string ObjectFileName
        {
            get
            {
                if (base.IsPropertySet("ObjectFileName"))
                {
                    return base.ActiveToolSwitches["ObjectFileName"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ObjectFileName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "Object File Name";
                toolSwitch.Description = "Specifies a name to override the default object file name; can be file or directory name.     (/Fo[name])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Fo";
                toolSwitch.Name = "ObjectFileName";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ObjectFileName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Fo", "bo"));
            }
        }
        public virtual string ProgramDataBaseFileName
        {
            get
            {
                if (base.IsPropertySet("ProgramDataBaseFileName"))
                {
                    return base.ActiveToolSwitches["ProgramDataBaseFileName"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ProgramDataBaseFileName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "Program Database File Name";
                toolSwitch.Description = "Specifies a name for a compiler-generated PDB file; also specifies base name for the required compiler-generated IDB file; can be file or directory name.     (/Fd[name])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Fd";
                toolSwitch.Name = "ProgramDataBaseFileName";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ProgramDataBaseFileName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("Fd", "Fd"));
            }
        }
        public virtual bool GenerateXMLDocumentationFiles
        {
            get
            {
                return base.IsPropertySet("GenerateXMLDocumentationFiles") && base.ActiveToolSwitches["GenerateXMLDocumentationFiles"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("GenerateXMLDocumentationFiles");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Generate XML Documentation Files";
                toolSwitch.Description = "Specifies that the compiler should generate XML documentation comment files (.XDC).     (/doc)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("XMLDocumentationFileName", "true", false, ""));
                toolSwitch.SwitchValue = "/doc";
                toolSwitch.Name = "GenerateXMLDocumentationFiles";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("GenerateXMLDocumentationFiles", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("doc", "doc"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("doc", "bo"));
            }
        }
        public virtual bool BrowseInformation
        {
            get
            {
                return base.IsPropertySet("BrowseInformation") && base.ActiveToolSwitches["BrowseInformation"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BrowseInformation");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Browse Information";
                toolSwitch.Description = "Enable Browse Information : Specifies level of browse information in .bsc file.     (/FR)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("BrowseInformationFile", "true", false, ""));
                toolSwitch.SwitchValue = "/FR";
                toolSwitch.Name = "BrowseInformation";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("BrowseInformation", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("FR", "Fr"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("FR", "bo"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("FR", "FR"));
            }
        }
        public virtual string CallingConvention
        {
            get
            {
                if (base.IsPropertySet("CallingConvention"))
                {
                    return base.ActiveToolSwitches["CallingConvention"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CallingConvention");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Calling Convention";
                toolSwitch.Description = "Select the default calling convention for your application (can be overridden by function).     (/Gd, /Gr, /Gz)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Cdecl", 
                        "/Gd"
                    }, 
                    new string[]
                    {
                        "FastCall", 
                        "/Gr"
                    }, 
                    new string[]
                    {
                        "StdCall", 
                        "/Gz"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CallingConvention", switchMap, value);
                toolSwitch.Name = "CallingConvention";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CallingConvention", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string CompileAs
        {
            get
            {
                if (base.IsPropertySet("CompileAs"))
                {
                    return base.ActiveToolSwitches["CompileAs"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CompileAs");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Compile As";
                toolSwitch.Description = "Select compile language option for .c and .cpp files.     (/TC, /TP)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Default", 
                        ""
                    }, 
                    new string[]
                    {
                        "CompileAsC", 
                        "/TC"
                    }, 
                    new string[]
                    {
                        "CompileAsCpp", 
                        "/TP"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CompileAs", switchMap, value);
                toolSwitch.Name = "CompileAs";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CompileAs", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] DisableSpecificWarnings
        {
            get
            {
                if (base.IsPropertySet("DisableSpecificWarnings"))
                {
                    return base.ActiveToolSwitches["DisableSpecificWarnings"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("DisableSpecificWarnings");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Disable Specific Warnings";
                toolSwitch.Description = "Disable the desired warning numbers; put numbers in a semi-colon delimited list.     (/wd[num])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/wd";
                toolSwitch.Name = "DisableSpecificWarnings";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("DisableSpecificWarnings", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] ForcedIncludeFiles
        {
            get
            {
                if (base.IsPropertySet("ForcedIncludeFiles"))
                {
                    return base.ActiveToolSwitches["ForcedIncludeFiles"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ForcedIncludeFiles");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Forced Include File";
                toolSwitch.Description = "one or more forced include files.     (/FI[name])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/FI";
                toolSwitch.Name = "ForcedIncludeFiles";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("ForcedIncludeFiles", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] ForcedUsingFiles
        {
            get
            {
                if (base.IsPropertySet("ForcedUsingFiles"))
                {
                    return base.ActiveToolSwitches["ForcedUsingFiles"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ForcedUsingFiles");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Forced #using File";
                toolSwitch.Description = "Specifies one or more forced #using files.     (/FU[name])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/FU";
                toolSwitch.Name = "ForcedUsingFiles";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("ForcedUsingFiles", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool ShowIncludes
        {
            get
            {
                return base.IsPropertySet("ShowIncludes") && base.ActiveToolSwitches["ShowIncludes"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ShowIncludes");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Show Includes";
                toolSwitch.Description = "Generates a list of include files with compiler output.     (/showIncludes)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/showIncludes";
                toolSwitch.Name = "ShowIncludes";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("ShowIncludes", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool EnablePREfast
        {
            get
            {
                return base.IsPropertySet("EnablePREfast") && base.ActiveToolSwitches["EnablePREfast"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EnablePREfast");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Code Analysis";
                toolSwitch.Description = "Enables code analysis functionality that identifies common coding defects in C/C++ code.     (/analyze)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/analyze";
                toolSwitch.ReverseSwitchValue = "/analyze-";
                toolSwitch.Name = "EnablePREfast";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("EnablePREfast", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("analyze", "analyze-"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("analyze-", "analyze"));
            }
        }
        public virtual bool UseFullPaths
        {
            get
            {
                return base.IsPropertySet("UseFullPaths") && base.ActiveToolSwitches["UseFullPaths"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UseFullPaths");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Use Full Paths";
                toolSwitch.Description = "Use full paths in diagnostic messages.     (/FC)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/FC";
                toolSwitch.Name = "UseFullPaths";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("UseFullPaths", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool OmitDefaultLibName
        {
            get
            {
                return base.IsPropertySet("OmitDefaultLibName") && base.ActiveToolSwitches["OmitDefaultLibName"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("OmitDefaultLibName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Omit Default Library Name";
                toolSwitch.Description = "Do not include default library names in .obj files.     (/Zl)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/Zl";
                toolSwitch.Name = "OmitDefaultLibName";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("OmitDefaultLibName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string ErrorReporting
        {
            get
            {
                if (base.IsPropertySet("ErrorReporting"))
                {
                    return base.ActiveToolSwitches["ErrorReporting"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ErrorReporting");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Internal Compiler Error Reporting";
                toolSwitch.Description = "Specifies how internal tool errors should be reported back to Microsoft.  The default in the IDE is prompt.  The default from command line builds is queue.     (/errorReport:[method])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "None", 
                        "/errorReport:none"
                    }, 
                    new string[]
                    {
                        "Prompt", 
                        "/errorReport:prompt"
                    }, 
                    new string[]
                    {
                        "Queue", 
                        "/errorReport:queue"
                    }, 
                    new string[]
                    {
                        "Send", 
                        "/errorReport:send"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("ErrorReporting", switchMap, value);
                toolSwitch.Name = "ErrorReporting";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("ErrorReporting", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] TreatSpecificWarningsAsErrors
        {
            get
            {
                if (base.IsPropertySet("TreatSpecificWarningsAsErrors"))
                {
                    return base.ActiveToolSwitches["TreatSpecificWarningsAsErrors"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TreatSpecificWarningsAsErrors");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Treat Specific Warnings As Errors";
                toolSwitch.Description = "Treats the specific compiler warning as an error where n is a compiler warning.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/we";
                toolSwitch.Name = "TreatSpecificWarningsAsErrors";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("TreatSpecificWarningsAsErrors", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool UseUnicodeForAssemblerListing
        {
            get
            {
                return base.IsPropertySet("UseUnicodeForAssemblerListing") && base.ActiveToolSwitches["UseUnicodeForAssemblerListing"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UseUnicodeForAssemblerListing");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Use Unicode For Assembler Listing";
                toolSwitch.Description = "Causes the output file to be created in UTF-8 format. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/FAu";
                toolSwitch.Name = "UseUnicodeForAssemblerListing";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("UseUnicodeForAssemblerListing", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        [Required]
        public virtual ITaskItem[] Sources
        {
            get
            {
                if (base.IsPropertySet("Sources"))
                {
                    return base.ActiveToolSwitches["Sources"].TaskItemArray;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("Sources");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.ITaskItemArray);
                toolSwitch.Separator = " ";
                toolSwitch.Required = true;
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.TaskItemArray = value;
                base.ActiveToolSwitches.Add("Sources", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool BuildingInIDE
        {
            get
            {
                return base.IsPropertySet("BuildingInIDE") && base.ActiveToolSwitches["BuildingInIDE"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BuildingInIDE");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "BuildingInIDE";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("BuildingInIDE", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual int ProcessorNumber
        {
            get
            {
                if (base.IsPropertySet("ProcessorNumber"))
                {
                    return base.ActiveToolSwitches["ProcessorNumber"].Number;
                }
                return 0;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ProcessorNumber");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Integer);
                toolSwitch.DisplayName = "Number of processors";
                toolSwitch.Description = "Number of processors.";
                toolSwitch.Parents.AddLast("MultiProcessorCompilation");
                toolSwitch.ArgumentRelationList = new ArrayList();
                if (base.ValidateInteger("ProcessorNumber", -2147483648, 2147483647, value))
                {
                    toolSwitch.IsValid = true;
                }
                else
                {
                    toolSwitch.IsValid = false;
                }
                toolSwitch.Name = "ProcessorNumber";
                toolSwitch.Number = value;
                base.ActiveToolSwitches.Add("ProcessorNumber", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string PrecompiledHeaderFile
        {
            get
            {
                if (base.IsPropertySet("PrecompiledHeaderFile"))
                {
                    return base.ActiveToolSwitches["PrecompiledHeaderFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PrecompiledHeaderFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "Precompiled Header File";
                toolSwitch.Description = "Specifies header file name to use when creating or using a precompiled header file. (/Yc[name], /Yu[name])";
                toolSwitch.Parents.AddLast("PrecompiledHeader");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "PrecompiledHeaderFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("PrecompiledHeaderFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string XMLDocumentationFileName
        {
            get
            {
                if (base.IsPropertySet("XMLDocumentationFileName"))
                {
                    return base.ActiveToolSwitches["XMLDocumentationFileName"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("XMLDocumentationFileName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "XML Documentation File Name";
                toolSwitch.Description = "Specifies the name of the generated XML documentation files; can be file or directory name.     (/doc[name])";
                toolSwitch.Parents.AddLast("GenerateXMLDocumentationFiles");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "XMLDocumentationFileName";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("XMLDocumentationFileName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string BrowseInformationFile
        {
            get
            {
                if (base.IsPropertySet("BrowseInformationFile"))
                {
                    return base.ActiveToolSwitches["BrowseInformationFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BrowseInformationFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.DisplayName = "Browse Information File";
                toolSwitch.Description = "Browse File : Specifies optional name for browser information file.     (/FR[name])";
                toolSwitch.Parents.AddLast("BrowseInformation");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "BrowseInformationFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("BrowseInformationFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        protected override ArrayList SwitchOrderList
        {
            get
            {
                return this.switchOrderList;
            }
        }
        protected override bool UseUnicodeOutput
        {
            get
            {
                return this.BuildingInIDE;
            }
        }
        [Output]
        public string[] ObjectFiles
        {
            get
            {
                return this.objectFiles;
            }
            set
            {
                this.objectFiles = value;
            }
        }
        [Output]
        public string[] BrowseInformationFiles
        {
            get
            {
                return this.browseInformationFiles;
            }
            set
            {
                this.browseInformationFiles = value;
            }
        }
        [Output]
        public string[] XmlDocumentationFiles
        {
            get
            {
                return this.xmlDocumentationFiles;
            }
            set
            {
                this.xmlDocumentationFiles = value;
            }
        }
        [Output]
        public ITaskItem[] PreprocessOutput
        {
            get
            {
                return this.preprocessOutput;
            }
            set
            {
                this.preprocessOutput = value;
            }
        }
        protected override string[] ReadTLogNames
        {
            get
            {
                return new string[]
                {
                    "cl.read.1.tlog", 
                    "cl.*.read.1.tlog"
                };
            }
        }
        protected override string[] WriteTLogNames
        {
            get
            {
                return new string[]
                {
                    "cl.write.1.tlog", 
                    "cl.*.write.1.tlog"
                };
            }
        }
        protected override string CommandTLogName
        {
            get
            {
                return "cl.command.1.tlog";
            }
        }
        protected override string TrackerIntermediateDirectory
        {
            get
            {
                if (this.TrackerLogDirectory != null)
                {
                    return this.TrackerLogDirectory;
                }
                return string.Empty;
            }
        }
        protected override ITaskItem[] TrackedInputFiles
        {
            get
            {
                return this.Sources;
            }
        }
        public AACL()
            : base(new ResourceManager("AMD.Build.AACLTasks.Resources", Assembly.GetExecutingAssembly()))
        {
            this.switchOrderList = new ArrayList();
            this.switchOrderList.Add("AlwaysAppend");
            this.switchOrderList.Add("AdditionalIncludeDirectories");
            this.switchOrderList.Add("AdditionalUsingDirectories");
            this.switchOrderList.Add("DebugInformationFormat");
            this.switchOrderList.Add("CompileAsManaged");
            this.switchOrderList.Add("SuppressStartupBanner");
            this.switchOrderList.Add("WarningLevel");
            this.switchOrderList.Add("TreatWarningAsError");
            this.switchOrderList.Add("TrackerLogDirectory");
            this.switchOrderList.Add("MultiProcessorCompilation");
            this.switchOrderList.Add("ProcessorNumber");
            this.switchOrderList.Add("KeepIntermediateFiles");
            this.switchOrderList.Add("Optimization");
            this.switchOrderList.Add("InlineFunctionExpansion");
            this.switchOrderList.Add("IntrinsicFunctions");
            this.switchOrderList.Add("FavorSizeOrSpeed");
            this.switchOrderList.Add("OmitFramePointers");
            this.switchOrderList.Add("EnableFiberSafeOptimizations");
            this.switchOrderList.Add("WholeProgramOptimization");
            this.switchOrderList.Add("PreprocessorDefinitions");
            this.switchOrderList.Add("UndefinePreprocessorDefinitions");
            this.switchOrderList.Add("UndefineAllPreprocessorDefinitions");
            this.switchOrderList.Add("IgnoreStandardIncludePath");
            this.switchOrderList.Add("PreprocessToFile");
            this.switchOrderList.Add("PreprocessOutputPath");
            this.switchOrderList.Add("PreprocessSuppressLineNumbers");
            this.switchOrderList.Add("PreprocessKeepComments");
            this.switchOrderList.Add("StringPooling");
            this.switchOrderList.Add("MinimalRebuild");
            this.switchOrderList.Add("ExceptionHandling");
            this.switchOrderList.Add("SmallerTypeCheck");
            this.switchOrderList.Add("BasicRuntimeChecks");
            this.switchOrderList.Add("RuntimeLibrary");
            this.switchOrderList.Add("StructMemberAlignment");
            this.switchOrderList.Add("BufferSecurityCheck");
            this.switchOrderList.Add("FunctionLevelLinking");
            this.switchOrderList.Add("EnableEnhancedInstructionSet");
            this.switchOrderList.Add("FloatingPointModel");
            this.switchOrderList.Add("FloatingPointExceptions");
            this.switchOrderList.Add("CreateHotpatchableImage");
            this.switchOrderList.Add("DisableLanguageExtensions");
            this.switchOrderList.Add("TreatWChar_tAsBuiltInType");
            this.switchOrderList.Add("ForceConformanceInForLoopScope");
            this.switchOrderList.Add("RuntimeTypeInfo");
            this.switchOrderList.Add("OpenMPSupport");
            this.switchOrderList.Add("PrecompiledHeader");
            this.switchOrderList.Add("PrecompiledHeaderFile");
            this.switchOrderList.Add("PrecompiledHeaderOutputFile");
            this.switchOrderList.Add("ExpandAttributedSource");
            this.switchOrderList.Add("AssemblerOutput");
            this.switchOrderList.Add("AssemblerListingLocation");
            this.switchOrderList.Add("ObjectFileName");
            this.switchOrderList.Add("ProgramDataBaseFileName");
            this.switchOrderList.Add("GenerateXMLDocumentationFiles");
            this.switchOrderList.Add("XMLDocumentationFileName");
            this.switchOrderList.Add("BrowseInformation");
            this.switchOrderList.Add("BrowseInformationFile");
            this.switchOrderList.Add("CallingConvention");
            this.switchOrderList.Add("CompileAs");
            this.switchOrderList.Add("DisableSpecificWarnings");
            this.switchOrderList.Add("ForcedIncludeFiles");
            this.switchOrderList.Add("ForcedUsingFiles");
            this.switchOrderList.Add("ShowIncludes");
            this.switchOrderList.Add("EnablePREfast");
            this.switchOrderList.Add("UseFullPaths");
            this.switchOrderList.Add("OmitDefaultLibName");
            this.switchOrderList.Add("ErrorReporting");
            this.switchOrderList.Add("TreatSpecificWarningsAsErrors");
            this.switchOrderList.Add("UseUnicodeForAssemblerListing");
            this.switchOrderList.Add("Sources");
            this.switchOrderList.Add("AdditionalOptions");
            this.switchOrderList.Add("BuildingInIDE");
        }
        protected override void ValidateRelations()
        {
            if (!base.IsSwitchValueSet("EP") && !base.IsSwitchValueSet("P") && !base.IsSwitchValueSet("E"))
            {
                base.RemoveSwitchToolBasedOnValue("C");
            }
            if (!base.IsSwitchValueSet("GF"))
            {
                base.RemoveSwitchToolBasedOnValue("cbstring");
            }
            if (!base.IsSwitchValueSet("Zi") && !base.IsSwitchValueSet("Z7"))
            {
                base.RemoveSwitchToolBasedOnValue("dlp");
            }
            if (!base.IsSwitchValueSet("EHs") && !base.IsSwitchValueSet("EHa") && !base.IsSwitchValueSet("GX"))
            {
                base.RemoveSwitchToolBasedOnValue("EHc");
            }
            if (!base.IsSwitchValueSet("ZI") && !base.IsSwitchValueSet("Zi"))
            {
                base.RemoveSwitchToolBasedOnValue("Gm");
            }
            if (!base.IsSwitchValueSet("clr\\:oldsyntax") && !base.IsSwitchValueSet("clr\\:pure") && !base.IsSwitchValueSet("clr") && !base.IsSwitchValueSet("clr\\:safe"))
            {
                base.RemoveSwitchToolBasedOnValue("LN");
            }
            if (!base.IsSwitchValueSet("MP"))
            {
                base.RemoveSwitchToolBasedOnValue("MPlowpri");
            }
        }
        public override string ApplyPrecompareCommandFilter(string cmdString)
        {
            string text = cmdString;
            int num;
            if ((num = text.IndexOf("/errorReport:")) >= 0)
            {
                int num2;
                if ((num2 = text.IndexOf(' ', num)) == -1)
                {
                    num2 = text.Length;
                }
                else
                {
                    num2++;
                }
                text = text.Remove(num, num2 - num);
            }
            if ((num = text.IndexOf("/MP")) >= 0)
            {
                int num2;
                if ((num2 = text.IndexOf(' ', num)) == -1)
                {
                    num2 = text.Length;
                }
                else
                {
                    num2++;
                }
                text = text.Remove(num, num2 - num);
            }
            return text;
        }
        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands)
        {
            int num = 0;
            try
            {
                num = base.TrackerExecuteTool(pathToTool, responseFileCommands, commandLineCommands);
            }
            finally
            {
                if (base.MinimalRebuildFromTracking || base.TrackFileAccess)
                {
                    CanonicalTrackedOutputFiles canonicalTrackedOutputFiles = new CanonicalTrackedOutputFiles(base.TLogWriteFiles);
                    CanonicalTrackedInputFiles canonicalTrackedInputFiles = new CanonicalTrackedInputFiles(base.TLogReadFiles, this.Sources, base.ExcludedInputPaths, canonicalTrackedOutputFiles, true, this.MaintainCompositeRootingMarkers);
                    DependencyFilter includeInTLog = new DependencyFilter(this.OutputDependencyFilter);
                    DependencyFilter dependencyFilter = new DependencyFilter(this.InputDependencyFilter);
                    this.trackedInputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
                    if (base.TrackedInputFilesToIgnore != null)
                    {
                        ITaskItem[] trackedInputFilesToIgnore = base.TrackedInputFilesToIgnore;
                        for (int i = 0; i < trackedInputFilesToIgnore.Length; i++)
                        {
                            ITaskItem taskItem = trackedInputFilesToIgnore[i];
                            this.trackedInputFilesToRemove.Add(taskItem.GetMetadata("FullPath"), taskItem);
                        }
                    }
                    this.trackedOutputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
                    if (base.TrackedOutputFilesToIgnore != null)
                    {
                        ITaskItem[] trackedOutputFilesToIgnore = base.TrackedOutputFilesToIgnore;
                        for (int j = 0; j < trackedOutputFilesToIgnore.Length; j++)
                        {
                            ITaskItem taskItem2 = trackedOutputFilesToIgnore[j];
                            this.trackedOutputFilesToRemove.Add(taskItem2.GetMetadata("FullPath"), taskItem2);
                        }
                    }
                    if (this.PreprocessToFile)
                    {
                        canonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled, this.preprocessOutput);
                        canonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled, this.preprocessOutput);
                    }
                    else
                    {
                        canonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled);
                        canonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled);
                    }
                    if (num != 0 && !this.MinimalRebuild)
                    {
                        ITaskItem[] array3;
                        ITaskItem[] upToDateSources;
                        if (!this.PreprocessToFile && base.SourcesCompiled.Length > 1)
                        {
                            KeyValuePair<string, bool>[] array = new KeyValuePair<string, bool>[]
                            {
                                new KeyValuePair<string, bool>("ObjectFile", true), 
                                new KeyValuePair<string, bool>("BrowseInformationFile", this.BrowseInformation), 
                                new KeyValuePair<string, bool>("XMLDocumentationFileName", this.GenerateXMLDocumentationFiles)
                            };
                            ITaskItem[] sources = this.Sources;
                            for (int k = 0; k < sources.Length; k++)
                            {
                                ITaskItem taskItem3 = sources[k];
                                string sourceKey = FileTracker.FormatRootingMarker(taskItem3);
                                KeyValuePair<string, bool>[] array2 = array;
                                for (int l = 0; l < array2.Length; l++)
                                {
                                    KeyValuePair<string, bool> keyValuePair = array2[l];
                                    string key = keyValuePair.Key;
                                    bool value = keyValuePair.Value;
                                    if (value)
                                    {
                                        canonicalTrackedOutputFiles.AddComputedOutputForSourceRoot(sourceKey, taskItem3.GetMetadata(key));
                                    }
                                }
                            }
                            array3 = canonicalTrackedInputFiles.ComputeSourcesNeedingCompilation();
                            List<ITaskItem> list = new List<ITaskItem>();
                            int num2 = 0;
                            ITaskItem[] sourcesCompiled = base.SourcesCompiled;
                            for (int m = 0; m < sourcesCompiled.Length; m++)
                            {
                                ITaskItem taskItem4 = sourcesCompiled[m];
                                if (num2 >= array3.Length)
                                {
                                    list.Add(taskItem4);
                                }
                                else
                                {
                                    if (!array3[num2].Equals(taskItem4))
                                    {
                                        list.Add(taskItem4);
                                    }
                                    else
                                    {
                                        num2++;
                                    }
                                }
                            }
                            upToDateSources = list.ToArray();
                            ITaskItem[] sources2 = this.Sources;
                            for (int n = 0; n < sources2.Length; n++)
                            {
                                ITaskItem taskItem5 = sources2[n];
                                string sourceRoot = FileTracker.FormatRootingMarker(taskItem5);
                                KeyValuePair<string, bool>[] array4 = array;
                                for (int num3 = 0; num3 < array4.Length; num3++)
                                {
                                    KeyValuePair<string, bool> keyValuePair2 = array4[num3];
                                    string key2 = keyValuePair2.Key;
                                    bool value2 = keyValuePair2.Value;
                                    if (value2)
                                    {
                                        canonicalTrackedOutputFiles.RemoveOutputForSourceRoot(sourceRoot, taskItem5.GetMetadata(key2));
                                    }
                                }
                            }
                        }
                        else
                        {
                            array3 = base.SourcesCompiled;
                            upToDateSources = new ITaskItem[0];
                        }
                        canonicalTrackedOutputFiles.RemoveEntriesForSource(array3, this.preprocessOutput);
                        canonicalTrackedOutputFiles.SaveTlog(includeInTLog);
                        canonicalTrackedInputFiles.RemoveEntriesForSource(array3);
                        canonicalTrackedInputFiles.SaveTlog(dependencyFilter);
                        this.ConstructCommandTLog(upToDateSources, dependencyFilter);
                    }
                    else
                    {
                        if (this.PreprocessToFile)
                        {
                            bool flag = true;
                            ITaskItem[] sourcesCompiled2 = base.SourcesCompiled;
                            for (int num4 = 0; num4 < sourcesCompiled2.Length; num4++)
                            {
                                ITaskItem taskItem6 = sourcesCompiled2[num4];
                                if (string.IsNullOrEmpty(taskItem6.GetMetadata("PreprocessOutputPath")))
                                {
                                    flag = (flag && this.MovePreprocessedOutput(taskItem6, canonicalTrackedOutputFiles));
                                }
                            }
                            if (flag)
                            {
                                this.AddPdbToCompactOutputs(base.SourcesCompiled, canonicalTrackedOutputFiles);
                                canonicalTrackedOutputFiles.SaveTlog(includeInTLog);
                                canonicalTrackedInputFiles.SaveTlog(dependencyFilter);
                                this.ConstructCommandTLog(base.SourcesCompiled, dependencyFilter);
                            }
                        }
                        else
                        {
                            this.AddPdbToCompactOutputs(base.SourcesCompiled, canonicalTrackedOutputFiles);
                            this.RemoveTaskSpecificInputs(canonicalTrackedInputFiles);
                            canonicalTrackedOutputFiles.SaveTlog(includeInTLog);
                            canonicalTrackedInputFiles.SaveTlog(dependencyFilter);
                            this.ConstructCommandTLog(base.SourcesCompiled, dependencyFilter);
                        }
                    }
                }
                else
                {
                    if (this.PreprocessToFile)
                    {
                        bool flag2 = true;
                        ITaskItem[] sourcesCompiled3 = base.SourcesCompiled;
                        for (int num5 = 0; num5 < sourcesCompiled3.Length; num5++)
                        {
                            ITaskItem taskItem7 = sourcesCompiled3[num5];
                            if (string.IsNullOrEmpty(taskItem7.GetMetadata("PreprocessOutputPath")))
                            {
                                flag2 = (flag2 && this.MovePreprocessedOutput(taskItem7, null));
                            }
                        }
                        if (!flag2)
                        {
                            num = -1;
                        }
                    }
                }
                //for (int k = 0; k < base.ActiveToolSwitches["Sources"].TaskItemArray.Length; k++)
                //{
                //    if (base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec.EndsWith(".obj"))
                //    {
                //        int i_len = base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec.Length;
                //        base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec.Remove(i_len - 4);
                //        base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec += ".fatobj";
                //        break;
                //    }
                //}
            }
            return num;
        }
        private bool InputDependencyFilter(string fullInputPath)
        {
            return !this.trackedInputFilesToRemove.ContainsKey(fullInputPath);
        }
        private bool OutputDependencyFilter(string fullOutputPath)
        {
            return !fullOutputPath.EndsWith(".TLH", StringComparison.OrdinalIgnoreCase) && !fullOutputPath.EndsWith(".TLI", StringComparison.OrdinalIgnoreCase) && !fullOutputPath.EndsWith(".DLL", StringComparison.OrdinalIgnoreCase) && !this.trackedOutputFilesToRemove.ContainsKey(fullOutputPath);
        }
        private bool MovePreprocessedOutput(ITaskItem source, CanonicalTrackedOutputFiles replaceOutputs)
        {
            string text = Helpers.GetOutputFileName(source.ItemSpec, this.ObjectFileName, "i");
            string text2 = source.ItemSpec;
            bool result = true;
            try
            {
                text2 = Path.GetFullPath(Path.ChangeExtension(Path.GetFileName(source.ItemSpec), ".i"));
                text = Path.GetFullPath(text);
                if (string.Compare(text2, text, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    if (File.Exists(text))
                    {
                        File.Delete(text);
                    }
                    if (File.Exists(text2))
                    {
                        base.Log.LogMessageFromResources(MessageImportance.Low, "Move.FileComment", new object[]
                        {
                            text2, 
                            text
                        });
                        File.Move(text2, text);
                    }
                }
                if (replaceOutputs != null)
                {
                    string text3 = FileTracker.FormatRootingMarker(this.Sources, this.preprocessOutput);
                    replaceOutputs.RemoveOutputForSourceRoot(text3, text2);
                    replaceOutputs.AddComputedOutputForSourceRoot(text3, text);
                }
            }
            catch (Exception ex)
            {
                base.Log.LogErrorWithCodeFromResources("Move.Error", new object[]
                {
                    text2, 
                    text, 
                    ex.Message
                });
                result = false;
            }
            return result;
        }
        private void ComputeObjectFiles()
        {
            this.ObjectFiles = new string[this.Sources.Length];
            int num = 0;
            ITaskItem[] sources = this.Sources;
            for (int i = 0; i < sources.Length; i++)
            {
                ITaskItem taskItem = sources[i];
                this.ObjectFiles[num] = Helpers.GetOutputFileName(taskItem.ItemSpec, this.ObjectFileName, "obj");
                //if (b_post_processing)
                //{
                //    int i_len = this.ObjectFiles[num].Length;
                //    this.ObjectFiles[num].Remove(i_len - 4);
                //    this.ObjectFiles[num] += ".fatobj";
                //}
                taskItem.SetMetadata("ObjectFile", this.ObjectFiles[num]);
                num++;
            }
        }
        private void ComputePreprocessedOutputFiles()
        {
            List<ITaskItem> list = new List<ITaskItem>();
            ITaskItem[] sources = this.Sources;
            for (int i = 0; i < sources.Length; i++)
            {
                ITaskItem taskItem = sources[i];
                string metadata = taskItem.GetMetadata("PreprocessOutputPath");
                string outputFileName;
                if (!string.IsNullOrEmpty(metadata))
                {
                    outputFileName = Helpers.GetOutputFileName(metadata, this.ObjectFileName, "i");
                }
                else
                {
                    outputFileName = Helpers.GetOutputFileName(taskItem.ItemSpec, this.ObjectFileName, "i");
                }
                string fullPath = Path.GetFullPath(outputFileName);
                taskItem.SetMetadata("PreprocessOutputFile", fullPath);
                ITaskItem taskItem2 = new TaskItem(outputFileName);
                taskItem.CopyMetadataTo(taskItem2);
                list.Add(taskItem2);
            }
            this.preprocessOutput = list.ToArray();
        }
        private void ComputeBrowseInformationFiles()
        {
            this.BrowseInformationFiles = new string[this.Sources.Length];
            int num = 0;
            ITaskItem[] sources = this.Sources;
            for (int i = 0; i < sources.Length; i++)
            {
                ITaskItem taskItem = sources[i];
                this.BrowseInformationFiles[num] = Helpers.GetOutputFileName(taskItem.ItemSpec, this.BrowseInformationFile, "sbr");
                taskItem.SetMetadata("BrowseInformationFile", this.BrowseInformationFiles[num]);
                num++;
            }
        }
        private void ComputeXmlDocumentationFiles()
        {
            this.XmlDocumentationFiles = new string[this.Sources.Length];
            int num = 0;
            ITaskItem[] sources = this.Sources;
            for (int i = 0; i < sources.Length; i++)
            {
                ITaskItem taskItem = sources[i];
                this.XmlDocumentationFiles[num] = Helpers.GetOutputFileName(taskItem.ItemSpec, this.XMLDocumentationFileName, "xdc");
                taskItem.SetMetadata("XMLDocumentationFileName", this.XmlDocumentationFiles[num]);
                num++;
            }
        }
        private void ConstructCommandTLog(ITaskItem[] upToDateSources, DependencyFilter inputFilter)
        {
            IDictionary<string, string> dictionary = base.MapSourcesToCommandLines();
            string str = base.GenerateCommandLineExceptSwitches(new string[]
            {
                "Sources"
            });
            if (upToDateSources != null)
            {
                for (int i = 0; i < upToDateSources.Length; i++)
                {
                    ITaskItem taskItem = upToDateSources[i];
                    string metadata = taskItem.GetMetadata("FullPath");
                    if (inputFilter == null || inputFilter(metadata))
                    {
                        dictionary[FileTracker.FormatRootingMarker(taskItem)] = str + " " + metadata.ToUpperInvariant();
                    }
                    else
                    {
                        dictionary.Remove(FileTracker.FormatRootingMarker(taskItem));
                    }
                }
            }
            base.WriteSourcesToCommandLinesTable(dictionary);
        }
        protected override bool ComputeOutOfDateSources()
        {
            if (base.MinimalRebuildFromTracking || base.TrackFileAccess)
            {
                this.AssignDefaultTLogPaths();
            }
            if (this.PreprocessToFile)
            {
                this.ComputePreprocessedOutputFiles();
            }
            if (base.MinimalRebuildFromTracking && !this.ForcedRebuildRequired())
            {
                CanonicalTrackedOutputFiles canonicalTrackedOutputFiles = new CanonicalTrackedOutputFiles(this, base.TLogWriteFiles, false);
                this.ComputeObjectFiles();
                this.ComputeBrowseInformationFiles();
                this.ComputeXmlDocumentationFiles();
                KeyValuePair<string, bool>[] array = new KeyValuePair<string, bool>[]
                {
                    new KeyValuePair<string, bool>("ObjectFile", true), 
                    new KeyValuePair<string, bool>("BrowseInformationFile", this.BrowseInformation), 
                    new KeyValuePair<string, bool>("XMLDocumentationFileName", this.GenerateXMLDocumentationFiles)
                };
                if (this.PreprocessToFile)
                {
                    base.RootSource = FileTracker.FormatRootingMarker(this.Sources, this.preprocessOutput);
                    canonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(base.RootSource, this.preprocessOutput);
                    array[0] = new KeyValuePair<string, bool>("PreprocessOutputFile", true);
                }
                ITaskItem[] sources = this.Sources;
                for (int i = 0; i < sources.Length; i++)
                {
                    ITaskItem taskItem = sources[i];
                    string sourceKey = FileTracker.FormatRootingMarker(taskItem);
                    KeyValuePair<string, bool>[] array2 = array;
                    for (int j = 0; j < array2.Length; j++)
                    {
                        KeyValuePair<string, bool> keyValuePair = array2[j];
                        string key = keyValuePair.Key;
                        bool value = keyValuePair.Value;
                        if (value)
                        {
                            canonicalTrackedOutputFiles.AddComputedOutputForSourceRoot(sourceKey, taskItem.GetMetadata(key));
                            if (File.Exists(taskItem.GetMetadata("ObjectFile")) && !File.Exists(taskItem.GetMetadata(key)))
                            {
                                File.Delete(taskItem.GetMetadata("ObjectFile"));
                            }
                        }
                    }
                }
                base.SourceDependencies = new CanonicalTrackedInputFiles(this, base.TLogReadFiles, this.Sources, base.ExcludedInputPaths, canonicalTrackedOutputFiles, true, this.MaintainCompositeRootingMarkers);
                ITaskItem[] sourcesOutOfDateThroughTracking = base.SourceDependencies.ComputeSourcesNeedingCompilation();
                List<ITaskItem> sourcesWithChangedCommandLines = this.GenerateSourcesOutOfDateDueToCommandLine();
                base.SourcesCompiled = base.MergeOutOfDateSourceLists(sourcesOutOfDateThroughTracking, sourcesWithChangedCommandLines);
                if (base.SourcesCompiled.Length == 0)
                {
                    base.SkippedExecution = true;
                    return base.SkippedExecution;
                }
                if (!this.MinimalRebuild || this.PreprocessToFile)
                {
                    base.SourceDependencies.RemoveEntriesForSource(base.SourcesCompiled);
                    base.SourceDependencies.SaveTlog();
                    canonicalTrackedOutputFiles = new CanonicalTrackedOutputFiles(this, base.TLogWriteFiles);
                    canonicalTrackedOutputFiles.RemoveEntriesForSource(base.SourcesCompiled, this.preprocessOutput);
                    canonicalTrackedOutputFiles.SaveTlog();
                    IDictionary<string, string> dictionary = base.MapSourcesToCommandLines();
                    ITaskItem[] sourcesCompiled = base.SourcesCompiled;
                    for (int k = 0; k < sourcesCompiled.Length; k++)
                    {
                        ITaskItem source = sourcesCompiled[k];
                        dictionary.Remove(FileTracker.FormatRootingMarker(source));
                    }
                    base.WriteSourcesToCommandLinesTable(dictionary);
                }
                this.AssignOutOfDateSources(base.SourcesCompiled);
            }
            else
            {
                base.SourcesCompiled = this.Sources;
            }
            if (this.PreprocessToFile)
            {
                if (!base.MinimalRebuildFromTracking)
                {
                    base.RootSource = FileTracker.FormatRootingMarker(this.Sources, this.preprocessOutput);
                }
            }
            else
            {
                if (base.TrackFileAccess)
                {
                    base.RootSource = FileTracker.FormatRootingMarker(base.SourcesCompiled);
                }
            }
            base.SkippedExecution = false;
            return base.SkippedExecution;
        }
        protected override void PostProcessSwitchList()
        {
            if (base.IsSetToTrue("MinimalRebuild") && this.MinimalRebuild && base.IsSetToTrue("MinimalRebuildForIDE"))
            {
                base.ActiveToolSwitches.Remove("MinimalRebuildForIDE");
            }
            this.ComputeObjectFiles();
        }
        protected override ITaskItem[] AssignOutOfDateSources(ITaskItem[] sources)
        {
            base.ActiveToolSwitches["Sources"].TaskItemArray = sources;
            return sources;
        }
        protected override bool ForcedRebuildRequired()
        {
            if (this.DebugInformationFormat != null && this.DebugInformationFormat != "OldStyle" && this.ProgramDataBaseFileName != null && !File.Exists(this.ProgramDataBaseFileName))
            {
                base.Log.LogMessageFromResources(MessageImportance.Low, "CL.RebuildingNoPDB", new object[]
                {
                    this.ProgramDataBaseFileName
                });
                return true;
            }
            return base.ForcedRebuildRequired();
        }
        private void AddPdbToCompactOutputs(ITaskItem[] sources, CanonicalTrackedOutputFiles compactOutputs)
        {
            if (this.DebugInformationFormat != null && this.DebugInformationFormat != "OldStyle" && this.ProgramDataBaseFileName != null)
            {
                string programDataBaseFileName = this.ProgramDataBaseFileName;
                for (int i = 0; i < sources.Length; i++)
                {
                    ITaskItem source = sources[i];
                    string sourceKey = FileTracker.FormatRootingMarker(source);
                    compactOutputs.AddComputedOutputForSourceRoot(sourceKey, programDataBaseFileName);
                }
            }
        }
        protected override void RemoveTaskSpecificInputs(CanonicalTrackedInputFiles compactInputs)
        {
            if (base.IsPropertySet("PrecompiledHeader") && this.PrecompiledHeader != "Create")
            {
                return;
            }
            if (base.IsPropertySet("PrecompiledHeaderOutputFile"))
            {
                string precompiledHeaderOutputFile = this.PrecompiledHeaderOutputFile;
                TaskItem dependencyToRemove = new TaskItem(precompiledHeaderOutputFile);
                compactInputs.RemoveDependencyFromEntry(this.Sources, dependencyToRemove);
                return;
            }
        }
    }
    public class AALink : TrackedVCToolTask
    {
        private ArrayList switchOrderList;
        private ITaskItem[] preprocessOutput = new ITaskItem[0];
        private string[] objectFiles;
        protected override string ToolName
        {
            get
            {
                return "aalink.exe";
            }
        }
        public virtual string OutputFile
        {
            get
            {
                if (base.IsPropertySet("OutputFile"))
                {
                    return base.ActiveToolSwitches["OutputFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("OutputFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Output File";
                toolSwitch.Description = "The /OUT option overrides the default name and location of the program that the linker creates.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/OUT";
                toolSwitch.Name = "OutputFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("OutputFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string ShowProgress
        {
            get
            {
                if (base.IsPropertySet("ShowProgress"))
                {
                    return base.ActiveToolSwitches["ShowProgress"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ShowProgress");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Show Progress";
                toolSwitch.Description = "Prints Linker Progress Messages";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "NotSet",
                        ""
                    },
                    new string[]
                    {
                        "LinkVerbose",
                        "/VERBOSE"
                    },
                    new string[]
                    {
                        "LinkVerboseLib",
                        "/VERBOSE:Lib"
                    },
                    new string[]
                    {
                        "LinkVerboseICF",
                        "/VERBOSE:ICF"
                    },
                    new string[]
                    {
                        "LinkVerboseREF",
                        "/VERBOSE:REF"
                    },
                    new string[]
                    {
                        "LinkVerboseSAFESEH",
                        "/VERBOSE:SAFESEH"
                    },
                    new string[]
                    {
                        "LinkVerboseCLR",
                        "/VERBOSE:CLR"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("ShowProgress", switchMap, value);
                toolSwitch.Name = "ShowProgress";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("ShowProgress", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string Version
        {
            get
            {
                if (base.IsPropertySet("Version"))
                {
                    return base.ActiveToolSwitches["Version"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("Version");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Version";
                toolSwitch.Description = "The /VERSION option tells the linker to put a version number in the header of the .exe or .dll file. Use DUMPBIN /HEADERS to see the image version field of the OPTIONAL HEADER VALUES to see the effect of /VERSION.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "Version";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/VERSION";
                base.ActiveToolSwitches.Add("Version", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool LinkIncremental
        {
            get
            {
                return base.IsPropertySet("LinkIncremental") && base.ActiveToolSwitches["LinkIncremental"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LinkIncremental");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Incremental Linking";
                toolSwitch.Description = "Enables incremental linking.     (/INCREMENTAL, /INCREMENTAL:NO)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/INCREMENTAL";
                toolSwitch.ReverseSwitchValue = "/INCREMENTAL:NO";
                toolSwitch.Name = "LinkIncremental";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("LinkIncremental", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("INCREMENTAL", "INCREMENTAL:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("INCREMENTAL:NO", "INCREMENTAL"));
            }
        }
        public virtual bool SuppressStartupBanner
        {
            get
            {
                return base.IsPropertySet("SuppressStartupBanner") && base.ActiveToolSwitches["SuppressStartupBanner"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SuppressStartupBanner");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Suppress Startup Banner";
                toolSwitch.Description = "The /NOLOGO option prevents display of the copyright message and version number. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/NOLOGO";
                toolSwitch.Name = "SuppressStartupBanner";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SuppressStartupBanner", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool IgnoreImportLibrary
        {
            get
            {
                return base.IsPropertySet("IgnoreImportLibrary") && base.ActiveToolSwitches["IgnoreImportLibrary"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("IgnoreImportLibrary");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Ignore Import Library";
                toolSwitch.Description = "Specifies that the import library generated by this configuration should not be imported into dependent projects.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "IgnoreImportLibrary";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("IgnoreImportLibrary", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool RegisterOutput
        {
            get
            {
                return base.IsPropertySet("RegisterOutput") && base.ActiveToolSwitches["RegisterOutput"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("RegisterOutput");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Register Output";
                toolSwitch.Description = "Specifies whether to register the primary output of this build.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "RegisterOutput";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("RegisterOutput", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool PerUserRedirection
        {
            get
            {
                return base.IsPropertySet("PerUserRedirection") && base.ActiveToolSwitches["PerUserRedirection"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PerUserRedirection");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Per-user Redirection";
                toolSwitch.Description = "When Register Output is enabled, Per-user redirection forces registry writes to HKEY_CLASSES_ROOT to be redirected to HKEY_CURRENT_USER.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "PerUserRedirection";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("PerUserRedirection", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] AdditionalLibraryDirectories
        {
            get
            {
                if (base.IsPropertySet("AdditionalLibraryDirectories"))
                {
                    return base.ActiveToolSwitches["AdditionalLibraryDirectories"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AdditionalLibraryDirectories");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Additional Library Directories";
                toolSwitch.Description = "Allows the user to override the environmental library path (/LIBPATH:folder)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/LIBPATH:";
                toolSwitch.Name = "AdditionalLibraryDirectories";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AdditionalLibraryDirectories", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool LinkLibraryDependencies
        {
            get
            {
                return base.IsPropertySet("LinkLibraryDependencies") && base.ActiveToolSwitches["LinkLibraryDependencies"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LinkLibraryDependencies");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Link Library Dependencies";
                toolSwitch.Description = "Specifies whether or not library outputs from project dependencies are automatically linked in.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "LinkLibraryDependencies";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("LinkLibraryDependencies", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool UseLibraryDependencyInputs
        {
            get
            {
                return base.IsPropertySet("UseLibraryDependencyInputs") && base.ActiveToolSwitches["UseLibraryDependencyInputs"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UseLibraryDependencyInputs");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Use Library Dependency Inputs";
                toolSwitch.Description = "Specifies whether or not the inputs to the librarian tool are used rather than the library file itself when linking in library outputs of project dependencies.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "UseLibraryDependencyInputs";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("UseLibraryDependencyInputs", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool LinkStatus
        {
            get
            {
                return base.IsPropertySet("LinkStatus") && base.ActiveToolSwitches["LinkStatus"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LinkStatus");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Link Status";
                toolSwitch.Description = "Specifies whether the linker should display a progress indicator showing what percentage of the link is complete. The default is to not display this status information. (/LTCG:STATUS|LTCG:NOSTATUS)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/LTCG:STATUS";
                toolSwitch.ReverseSwitchValue = "/LTCG:NOSTATUS";
                toolSwitch.Name = "LinkStatus";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("LinkStatus", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("LTCG:STATUS", "LTCG:NOSTATUS"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("LTCG:NOSTATUS", "LTCG:STATUS"));
            }
        }
        public virtual bool PreventDllBinding
        {
            get
            {
                return base.IsPropertySet("PreventDllBinding") && base.ActiveToolSwitches["PreventDllBinding"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("PreventDllBinding");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Prevent Dll Binding";
                toolSwitch.Description = "/ALLOWBIND:NO sets a bit in a DLL's header that indicates to Bind.exe that the image is not allowed to be bound. You may not want a DLL to be bound if it has been digitally signed (binding invalidates the signature).";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ALLOWBIND";
                toolSwitch.ReverseSwitchValue = "/ALLOWBIND:NO";
                toolSwitch.Name = "PreventDllBinding";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("PreventDllBinding", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("ALLOWBIND", "ALLOWBIND:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("ALLOWBIND:NO", "ALLOWBIND"));
            }
        }
        public virtual bool TreatLinkerWarningAsErrors
        {
            get
            {
                return base.IsPropertySet("TreatLinkerWarningAsErrors") && base.ActiveToolSwitches["TreatLinkerWarningAsErrors"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TreatLinkerWarningAsErrors");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Treat Linker Warning As Errors";
                toolSwitch.Description = "/WX causes no output file to be generated if the linker generates a warning.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/WX";
                toolSwitch.ReverseSwitchValue = "/WX:NO";
                toolSwitch.Name = "TreatLinkerWarningAsErrors";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("TreatLinkerWarningAsErrors", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("WX", "WX:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("WX:NO", "WX"));
            }
        }
        public virtual string ForceFileOutput
        {
            get
            {
                if (base.IsPropertySet("ForceFileOutput"))
                {
                    return base.ActiveToolSwitches["ForceFileOutput"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ForceFileOutput");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Force File Output";
                toolSwitch.Description = "The /FORCE option tells the linker to create an .exe file or DLL even if a symbol is referenced but not defined or is multiply defined. It may create invalid exe file ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Enabled",
                        "/FORCE"
                    },
                    new string[]
                    {
                        "MultiplyDefinedSymbolOnly",
                        "/FORCE:MULTIPLE"
                    },
                    new string[]
                    {
                        "UndefinedSymbolOnly",
                        "/FORCE:UNRESOLVED"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("ForceFileOutput", switchMap, value);
                toolSwitch.Name = "ForceFileOutput";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("ForceFileOutput", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string CreateHotPatchableImage
        {
            get
            {
                if (base.IsPropertySet("CreateHotPatchableImage"))
                {
                    return base.ActiveToolSwitches["CreateHotPatchableImage"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CreateHotPatchableImage");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Create Hot Patchable Image";
                toolSwitch.Description = "Prepares an image for hotpatching.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Enabled",
                        "/FUNCTIONPADMIN"
                    },
                    new string[]
                    {
                        "X86Image",
                        "/FUNCTIONPADMIN:5"
                    },
                    new string[]
                    {
                        "X64Image",
                        "/FUNCTIONPADMIN:6"
                    },
                    new string[]
                    {
                        "ItaniumImage",
                        "/FUNCTIONPADMIN:16"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CreateHotPatchableImage", switchMap, value);
                toolSwitch.Name = "CreateHotPatchableImage";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CreateHotPatchableImage", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string SpecifySectionAttributes
        {
            get
            {
                if (base.IsPropertySet("SpecifySectionAttributes"))
                {
                    return base.ActiveToolSwitches["SpecifySectionAttributes"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SpecifySectionAttributes");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Specify Section Attributes";
                toolSwitch.Description = "The /SECTION option changes the attributes of a section, overriding the attributes set when the .obj file for the section was compiled.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "SpecifySectionAttributes";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/SECTION";
                base.ActiveToolSwitches.Add("SpecifySectionAttributes", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool KeepIntermediateFiles
        {
            get
            {
                return base.IsPropertySet("KeepIntermediateFiles") && base.ActiveToolSwitches["KeepIntermediateFiles"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("KeepIntermediateFiles");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Keep Intermediate Files";
                toolSwitch.Description = "Disables deletion of AMD specific intermediate files.    (/keeptmp)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/keeptmp";
                toolSwitch.Name = "KeepIntermediateFiles";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("KeepIntermediateFiles", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string MSDOSStubFileName
        {
            get
            {
                if (base.IsPropertySet("MSDOSStubFileName"))
                {
                    return base.ActiveToolSwitches["MSDOSStubFileName"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MSDOSStubFileName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "MS-DOS Stub File Name";
                toolSwitch.Description = "The /STUB option attaches an MS-DOS stub program to a Win32 program. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/STUB";
                toolSwitch.Name = "MSDOSStubFileName";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("MSDOSStubFileName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string TrackerLogDirectory
        {
            get
            {
                if (base.IsPropertySet("TrackerLogDirectory"))
                {
                    return base.ActiveToolSwitches["TrackerLogDirectory"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TrackerLogDirectory");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Directory);
                toolSwitch.DisplayName = "Tracker Log Directory";
                toolSwitch.Description = "Tracker log directory.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Value = VCToolTask.EnsureTrailingSlash(value);
                base.ActiveToolSwitches.Add("TrackerLogDirectory", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] AdditionalDependencies
        {
            get
            {
                if (base.IsPropertySet("AdditionalDependencies"))
                {
                    return base.ActiveToolSwitches["AdditionalDependencies"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AdditionalDependencies");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Additional Dependencies";
                toolSwitch.Description = "Specifies additional items to add to the link command line [i.e. kernel32.lib] ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "AdditionalDependencies";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AdditionalDependencies", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool IgnoreAllDefaultLibraries
        {
            get
            {
                return base.IsPropertySet("IgnoreAllDefaultLibraries") && base.ActiveToolSwitches["IgnoreAllDefaultLibraries"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("IgnoreAllDefaultLibraries");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Ignore All Default Libraries";
                toolSwitch.Description = "The /NODEFAULTLIB option tells the linker to remove one or more default libraries from the list of libraries it searches when resolving external references. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/NODEFAULTLIB";
                toolSwitch.Name = "IgnoreAllDefaultLibraries";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("IgnoreAllDefaultLibraries", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] IgnoreSpecificDefaultLibraries
        {
            get
            {
                if (base.IsPropertySet("IgnoreSpecificDefaultLibraries"))
                {
                    return base.ActiveToolSwitches["IgnoreSpecificDefaultLibraries"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("IgnoreSpecificDefaultLibraries");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Ignore Specific Default Libraries";
                toolSwitch.Description = "Specifies one or more names of default libraries to ignore; separate multiple libraries with semi-colons.     (/NODEFAULTLIB:[name, name, ...])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/NODEFAULTLIB:";
                toolSwitch.Name = "IgnoreSpecificDefaultLibraries";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("IgnoreSpecificDefaultLibraries", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string ModuleDefinitionFile
        {
            get
            {
                if (base.IsPropertySet("ModuleDefinitionFile"))
                {
                    return base.ActiveToolSwitches["ModuleDefinitionFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ModuleDefinitionFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Module Definition File";
                toolSwitch.Description = "The /DEF option passes a module-definition file (.def) to the linker. Only one .def file can be specified to LINK. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DEF";
                toolSwitch.Name = "ModuleDefinitionFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ModuleDefinitionFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] AddModuleNamesToAssembly
        {
            get
            {
                if (base.IsPropertySet("AddModuleNamesToAssembly"))
                {
                    return base.ActiveToolSwitches["AddModuleNamesToAssembly"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AddModuleNamesToAssembly");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Add Module to Assembly";
                toolSwitch.Description = "The /ASSEMBLYMODULE option allows you to add a module reference to an assembly. Type information in the module will not be available to the assembly program that added the module reference. However, type information in the module will be available to any program that references the assembly.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ASSEMBLYMODULE:";
                toolSwitch.Name = "AddModuleNamesToAssembly";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AddModuleNamesToAssembly", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] EmbedManagedResourceFile
        {
            get
            {
                if (base.IsPropertySet("EmbedManagedResourceFile"))
                {
                    return base.ActiveToolSwitches["EmbedManagedResourceFile"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EmbedManagedResourceFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Embed Managed Resource File";
                toolSwitch.Description = "/ASSEMBLYRESOURCE embeds a resource file in the output file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ASSEMBLYRESOURCE:";
                toolSwitch.Name = "EmbedManagedResourceFile";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("EmbedManagedResourceFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] ForceSymbolReferences
        {
            get
            {
                if (base.IsPropertySet("ForceSymbolReferences"))
                {
                    return base.ActiveToolSwitches["ForceSymbolReferences"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ForceSymbolReferences");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Force Symbol References";
                toolSwitch.Description = "The /INCLUDE option tells the linker to add a specified symbol to the symbol table.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/INCLUDE:";
                toolSwitch.Name = "ForceSymbolReferences";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("ForceSymbolReferences", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] DelayLoadDLLs
        {
            get
            {
                if (base.IsPropertySet("DelayLoadDLLs"))
                {
                    return base.ActiveToolSwitches["DelayLoadDLLs"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("DelayLoadDLLs");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Delay Loaded Dlls";
                toolSwitch.Description = "The /DELAYLOAD option causes delayed loading of DLLs. The dllname specifies a DLL to delay load. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DELAYLOAD:";
                toolSwitch.Name = "DelayLoadDLLs";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("DelayLoadDLLs", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] AssemblyLinkResource
        {
            get
            {
                if (base.IsPropertySet("AssemblyLinkResource"))
                {
                    return base.ActiveToolSwitches["AssemblyLinkResource"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AssemblyLinkResource");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Assembly Link Resource";
                toolSwitch.Description = "The /ASSEMBLYLINKRESOURCE option creates a link to a .NET Framework resource in the output file; the resource file is not placed in the output file. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ASSEMBLYLINKRESOURCE:";
                toolSwitch.Name = "AssemblyLinkResource";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AssemblyLinkResource", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool GenerateManifest
        {
            get
            {
                return base.IsPropertySet("GenerateManifest") && base.ActiveToolSwitches["GenerateManifest"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("GenerateManifest");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Generate Manifest";
                toolSwitch.Description = "/MANIFEST specifies that the linker should create a side-by-side manifest file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/MANIFEST";
                toolSwitch.ReverseSwitchValue = "/MANIFEST:NO";
                toolSwitch.Name = "GenerateManifest";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("GenerateManifest", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("MANIFEST", "MANIFEST:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("MANIFEST:NO", "MANIFEST"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("MANIFEST:NO", "MANIFESTFILE"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("MANIFEST:NO", "MANIFESTUAC:"));
            }
        }
        public virtual string ManifestFile
        {
            get
            {
                if (base.IsPropertySet("ManifestFile"))
                {
                    return base.ActiveToolSwitches["ManifestFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ManifestFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Manifest File";
                toolSwitch.Description = "/MANIFESTFILE lets you change the default name of the manifest file. The default name of the manifest file is the file name with .manifest appended.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ManifestFile";
                toolSwitch.Name = "ManifestFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ManifestFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string[] AdditionalManifestDependencies
        {
            get
            {
                if (base.IsPropertySet("AdditionalManifestDependencies"))
                {
                    return base.ActiveToolSwitches["AdditionalManifestDependencies"].StringList;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AdditionalManifestDependencies");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);
                toolSwitch.DisplayName = "Additional Manifest Dependencies";
                toolSwitch.Description = "/MANIFESTDEPENDENCY lets you specify attributes that will be placed in the dependency section of the manifest file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/MANIFESTDEPENDENCY:";
                toolSwitch.Name = "AdditionalManifestDependencies";
                toolSwitch.StringList = value;
                base.ActiveToolSwitches.Add("AdditionalManifestDependencies", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool AllowIsolation
        {
            get
            {
                return base.IsPropertySet("AllowIsolation") && base.ActiveToolSwitches["AllowIsolation"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AllowIsolation");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Allow Isolation";
                toolSwitch.Description = "Specifies behavior for manifest lookup. (/ALLOWISOLATION:NO)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ReverseSwitchValue = "/ALLOWISOLATION:NO";
                toolSwitch.Name = "AllowIsolation";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("AllowIsolation", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool EnableUAC
        {
            get
            {
                return base.IsPropertySet("EnableUAC") && base.ActiveToolSwitches["EnableUAC"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EnableUAC");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable User Account Control (UAC)";
                toolSwitch.Description = "Specifies whether or not User Account Control is enabled.  (/MANIFESTUAC, /MANIFESTUAC:NO)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("UACExecutionLevel", "true", true, ""));
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("UACUIAccess", "true", true, " "));
                toolSwitch.SwitchValue = "/MANIFESTUAC:";
                toolSwitch.ReverseSwitchValue = "/MANIFESTUAC:NO";
                toolSwitch.Name = "EnableUAC";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("EnableUAC", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool GenerateDebugInformation
        {
            get
            {
                return base.IsPropertySet("GenerateDebugInformation") && base.ActiveToolSwitches["GenerateDebugInformation"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("GenerateDebugInformation");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Generate Debug Info";
                toolSwitch.Description = "The /DEBUG option creates debugging information for the .exe file or DLL.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DEBUG";
                toolSwitch.Name = "GenerateDebugInformation";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("GenerateDebugInformation", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string ProgramDatabaseFile
        {
            get
            {
                if (base.IsPropertySet("ProgramDatabaseFile"))
                {
                    return base.ActiveToolSwitches["ProgramDatabaseFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ProgramDatabaseFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Generate Program Database File";
                toolSwitch.Description = "By default, when /DEBUG is specified, the linker creates a program database (PDB) which holds debugging information. The default file name for the PDB has the base name of the program and the extension .pdb.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/PDB";
                toolSwitch.Name = "ProgramDatabaseFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ProgramDatabaseFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string StripPrivateSymbols
        {
            get
            {
                if (base.IsPropertySet("StripPrivateSymbols"))
                {
                    return base.ActiveToolSwitches["StripPrivateSymbols"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("StripPrivateSymbols");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Strip Private Symbols";
                toolSwitch.Description = "The /PDBSTRIPPED option creates a second program database (PDB) file when you build your program image with any of the compiler or linker options that generate a PDB file (/DEBUG, /Z7, /Zd, or /Zi).";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/PDBSTRIPPED";
                toolSwitch.Name = "StripPrivateSymbols";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("StripPrivateSymbols", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool GenerateMapFile
        {
            get
            {
                return base.IsPropertySet("GenerateMapFile") && base.ActiveToolSwitches["GenerateMapFile"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("GenerateMapFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Generate Map File";
                toolSwitch.Description = "The /MAP option tells the linker to create a mapfile.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("MapFileName", "true", false, ""));
                toolSwitch.SwitchValue = "/MAP";
                toolSwitch.Name = "GenerateMapFile";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("GenerateMapFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool MapExports
        {
            get
            {
                return base.IsPropertySet("MapExports") && base.ActiveToolSwitches["MapExports"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MapExports");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Map Exports";
                toolSwitch.Description = "The /MAPINFO option tells the linker to include the specified information in a mapfile, which is created if you specify the /MAP option. EXPORTS tells the linker to include exported functions.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/MAPINFO:EXPORTS";
                toolSwitch.Name = "MapExports";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("MapExports", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool AssemblyDebug
        {
            get
            {
                return base.IsPropertySet("AssemblyDebug") && base.ActiveToolSwitches["AssemblyDebug"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("AssemblyDebug");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Debuggable Assembly";
                toolSwitch.Description = "/ASSEMBLYDEBUG emits the DebuggableAttribute attribute with debug information tracking and disables JIT optimizations.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ASSEMBLYDEBUG";
                toolSwitch.ReverseSwitchValue = "/ASSEMBLYDEBUG:DISABLE";
                toolSwitch.Name = "AssemblyDebug";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("AssemblyDebug", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("ASSEMBLYDEBUG", "ASSEMBLYDEBUG:DISABLE"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("ASSEMBLYDEBUG:DISABLE", "ASSEMBLYDEBUG"));
            }
        }
        public virtual string SubSystem
        {
            get
            {
                if (base.IsPropertySet("SubSystem"))
                {
                    return base.ActiveToolSwitches["SubSystem"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SubSystem");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "SubSystem";
                toolSwitch.Description = "The /SUBSYSTEM option tells the operating system how to run the .exe file.The choice of subsystem affects the entry point symbol (or entry point function) that the linker will choose.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("MinimumRequiredVersion", "", false, ""));
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "NotSet",
                        ""
                    },
                    new string[]
                    {
                        "Console",
                        "/SUBSYSTEM:CONSOLE"
                    },
                    new string[]
                    {
                        "Windows",
                        "/SUBSYSTEM:WINDOWS"
                    },
                    new string[]
                    {
                        "Native",
                        "/SUBSYSTEM:NATIVE"
                    },
                    new string[]
                    {
                        "EFI Application",
                        "/SUBSYSTEM:EFI_APPLICATION"
                    },
                    new string[]
                    {
                        "EFI Boot Service Driver",
                        "/SUBSYSTEM:EFI_BOOT_SERVICE_DRIVER"
                    },
                    new string[]
                    {
                        "EFI ROM",
                        "/SUBSYSTEM:EFI_ROM"
                    },
                    new string[]
                    {
                        "EFI Runtime",
                        "/SUBSYSTEM:EFI_RUNTIME_DRIVER"
                    },
                    new string[]
                    {
                        "WindowsCE",
                        "/SUBSYSTEM:WINDOWSCE"
                    },
                    new string[]
                    {
                        "POSIX",
                        "/SUBSYSTEM:POSIX"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("SubSystem", switchMap, value);
                toolSwitch.Name = "SubSystem";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("SubSystem", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string HeapReserveSize
        {
            get
            {
                if (base.IsPropertySet("HeapReserveSize"))
                {
                    return base.ActiveToolSwitches["HeapReserveSize"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("HeapReserveSize");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Heap Reserve Size";
                toolSwitch.Description = "Specifies total heap allocation size in virtual memory. Default is 1MB.    (/HEAP:reserve)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("HeapCommitSize", "", false, ","));
                toolSwitch.Name = "HeapReserveSize";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/HEAP";
                base.ActiveToolSwitches.Add("HeapReserveSize", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string StackReserveSize
        {
            get
            {
                if (base.IsPropertySet("StackReserveSize"))
                {
                    return base.ActiveToolSwitches["StackReserveSize"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("StackReserveSize");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Stack Reserve Size";
                toolSwitch.Description = "Specifies the total stack allocation size in virtual memory. Default is 1MB.     (/STACK:reserve)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation("StackCommitSize", "", false, ","));
                toolSwitch.Name = "StackReserveSize";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/STACK";
                base.ActiveToolSwitches.Add("StackReserveSize", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool LargeAddressAware
        {
            get
            {
                return base.IsPropertySet("LargeAddressAware") && base.ActiveToolSwitches["LargeAddressAware"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LargeAddressAware");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable Large Addresses";
                toolSwitch.Description = "The /LARGEADDRESSAWARE option tells the linker that the application can handle addresses larger than 2 gigabytes. By default, /LARGEADDRESSAWARE:NO is enabled if /LARGEADDRESSAWARE is not otherwise specified on the linker line.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/LARGEADDRESSAWARE";
                toolSwitch.ReverseSwitchValue = "/LARGEADDRESSAWARE:NO";
                toolSwitch.Name = "LargeAddressAware";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("LargeAddressAware", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("LARGEADDRESSAWARE", "LARGEADDRESSAWARE:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("LARGEADDRESSAWARE:NO", "LARGEADDRESSAWARE"));
            }
        }
        public virtual bool TerminalServerAware
        {
            get
            {
                return base.IsPropertySet("TerminalServerAware") && base.ActiveToolSwitches["TerminalServerAware"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TerminalServerAware");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Terminal Server";
                toolSwitch.Description = "The /TSAWARE option sets a flag in the IMAGE_OPTIONAL_HEADER DllCharacteristics field in the program image's optional header. When this flag is set, Terminal Server will not make certain changes to the application.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/TSAWARE";
                toolSwitch.ReverseSwitchValue = "/TSAWARE:NO";
                toolSwitch.Name = "TerminalServerAware";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("TerminalServerAware", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("TSAWARE", "TSAWARE:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("TSAWARE:NO", "TSAWARE"));
            }
        }
        public virtual bool SwapRunFromCD
        {
            get
            {
                return base.IsPropertySet("SwapRunFromCD") && base.ActiveToolSwitches["SwapRunFromCD"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SwapRunFromCD");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Swap Run From CD";
                toolSwitch.Description = "The /SWAPRUN option tells the operating system to first copy the linker output to a swap file, and then run the image from there. This is a Windows NT 4.0 (and later) feature.When CD is specified, the operating system will copy the image on a removable disk to a page file and then load it.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/SWAPRUN:CD";
                toolSwitch.Name = "SwapRunFromCD";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SwapRunFromCD", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool SwapRunFromNET
        {
            get
            {
                return base.IsPropertySet("SwapRunFromNET") && base.ActiveToolSwitches["SwapRunFromNET"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SwapRunFromNET");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Swap Run From Network";
                toolSwitch.Description = "The /SWAPRUN option tells the operating system to first copy the linker output to a swap file, and then run the image from there. This is a Windows NT 4.0 (and later) feature. If NET is specified, the operating system will first copy the binary image from the network to a swap file and load it from there. This option is useful for running applications over the network.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/SWAPRUN:NET";
                toolSwitch.Name = "SwapRunFromNET";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SwapRunFromNET", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string Driver
        {
            get
            {
                if (base.IsPropertySet("Driver"))
                {
                    return base.ActiveToolSwitches["Driver"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("Driver");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Driver";
                toolSwitch.Description = "Use the /DRIVER linker option to build a Windows NT kernel mode driver.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "NotSet",
                        ""
                    },
                    new string[]
                    {
                        "Driver",
                        "/Driver"
                    },
                    new string[]
                    {
                        "UpOnly",
                        "/DRIVER:UPONLY"
                    },
                    new string[]
                    {
                        "WDM",
                        "/DRIVER:WDM"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("Driver", switchMap, value);
                toolSwitch.Name = "Driver";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("Driver", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool OptimizeReferences
        {
            get
            {
                return base.IsPropertySet("OptimizeReferences") && base.ActiveToolSwitches["OptimizeReferences"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("OptimizeReferences");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "References";
                toolSwitch.Description = "/OPT:REF eliminates functions and/or data that are never referenced while /OPT:NOREF keeps functions and/or data that are never referenced. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/OPT:REF";
                toolSwitch.ReverseSwitchValue = "/OPT:NOREF";
                toolSwitch.Name = "OptimizeReferences";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("OptimizeReferences", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool EnableCOMDATFolding
        {
            get
            {
                return base.IsPropertySet("EnableCOMDATFolding") && base.ActiveToolSwitches["EnableCOMDATFolding"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EnableCOMDATFolding");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Enable COMDAT Folding";
                toolSwitch.Description = "Use /OPT:ICF[=iterations] to perform identical COMDAT folding. ";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/OPT:ICF";
                toolSwitch.ReverseSwitchValue = "/OPT:NOICF";
                toolSwitch.Name = "EnableCOMDATFolding";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("EnableCOMDATFolding", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string FunctionOrder
        {
            get
            {
                if (base.IsPropertySet("FunctionOrder"))
                {
                    return base.ActiveToolSwitches["FunctionOrder"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("FunctionOrder");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":@";
                toolSwitch.DisplayName = "Function Order";
                toolSwitch.Description = "The /ORDER option tells LINK to optimize your program by placing certain COMDATs into the image in a predetermined order. LINK places the functions in the specified order within each section in the image.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/ORDER";
                toolSwitch.Name = "FunctionOrder";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("FunctionOrder", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string ProfileGuidedDatabase
        {
            get
            {
                if (base.IsPropertySet("ProfileGuidedDatabase"))
                {
                    return base.ActiveToolSwitches["ProfileGuidedDatabase"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ProfileGuidedDatabase");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Profile Guided Database";
                toolSwitch.Description = "Specify .pgd file for profile guided optionizations. (/PGD)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/PGD";
                toolSwitch.Name = "ProfileGuidedDatabase";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ProfileGuidedDatabase", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string LinkTimeCodeGeneration
        {
            get
            {
                if (base.IsPropertySet("LinkTimeCodeGeneration"))
                {
                    return base.ActiveToolSwitches["LinkTimeCodeGeneration"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LinkTimeCodeGeneration");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Link Time Code Generation";
                toolSwitch.Description = "Specifies link-time code generation";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Default",
                        ""
                    },
                    new string[]
                    {
                        "UseLinkTimeCodeGeneration",
                        "/LTCG"
                    },
                    new string[]
                    {
                        "PGInstrument",
                        "/LTCG:PGInstrument"
                    },
                    new string[]
                    {
                        "PGOptimization",
                        "/LTCG:PGOptimize"
                    },
                    new string[]
                    {
                        "PGUpdate",
                        "/LTCG:PGUpdate"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("LinkTimeCodeGeneration", switchMap, value);
                toolSwitch.Name = "LinkTimeCodeGeneration";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("LinkTimeCodeGeneration", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string MidlCommandFile
        {
            get
            {
                if (base.IsPropertySet("MidlCommandFile"))
                {
                    return base.ActiveToolSwitches["MidlCommandFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MidlCommandFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":@";
                toolSwitch.DisplayName = "MIDL Commands";
                toolSwitch.Description = "Specify MIDL command line Options (/MIDL:@responsefile)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/MIDL";
                toolSwitch.Name = "MidlCommandFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("MidlCommandFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool IgnoreEmbeddedIDL
        {
            get
            {
                return base.IsPropertySet("IgnoreEmbeddedIDL") && base.ActiveToolSwitches["IgnoreEmbeddedIDL"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("IgnoreEmbeddedIDL");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Ignore Embedded IDL";
                toolSwitch.Description = "The /IGNOREIDL option specifies that any IDL attributes in source code should not be processed into an .idl file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/IGNOREIDL";
                toolSwitch.Name = "IgnoreEmbeddedIDL";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("IgnoreEmbeddedIDL", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string MergedIDLBaseFileName
        {
            get
            {
                if (base.IsPropertySet("MergedIDLBaseFileName"))
                {
                    return base.ActiveToolSwitches["MergedIDLBaseFileName"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MergedIDLBaseFileName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Merged IDL Base File Name";
                toolSwitch.Description = "The /IDLOUT option specifies the name and extension of the .idl file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/IDLOUT";
                toolSwitch.Name = "MergedIDLBaseFileName";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("MergedIDLBaseFileName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string TypeLibraryFile
        {
            get
            {
                if (base.IsPropertySet("TypeLibraryFile"))
                {
                    return base.ActiveToolSwitches["TypeLibraryFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TypeLibraryFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Type Library";
                toolSwitch.Description = "The /TLBOUT option specifies the name and extension of the .tlb file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/TLBOUT";
                toolSwitch.Name = "TypeLibraryFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("TypeLibraryFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual int TypeLibraryResourceID
        {
            get
            {
                if (base.IsPropertySet("TypeLibraryResourceID"))
                {
                    return base.ActiveToolSwitches["TypeLibraryResourceID"].Number;
                }
                return 0;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TypeLibraryResourceID");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Integer);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "TypeLib Resource ID";
                toolSwitch.Description = "Allows you to specify the resource ID of the linker-generated type library. (/TLBID:id)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                if (base.ValidateInteger("/TLBID", -2147483648, 2147483647, value))
                {
                    toolSwitch.IsValid = true;
                }
                else
                {
                    toolSwitch.IsValid = false;
                }
                toolSwitch.Name = "TypeLibraryResourceID";
                toolSwitch.SwitchValue = "/TLBID";
                toolSwitch.Number = value;
                base.ActiveToolSwitches.Add("TypeLibraryResourceID", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string EntryPointSymbol
        {
            get
            {
                if (base.IsPropertySet("EntryPointSymbol"))
                {
                    return base.ActiveToolSwitches["EntryPointSymbol"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("EntryPointSymbol");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Entry Point";
                toolSwitch.Description = "The /ENTRY option specifies an entry point function as the starting address for an .exe file or DLL.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "EntryPointSymbol";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/ENTRY";
                base.ActiveToolSwitches.Add("EntryPointSymbol", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool NoEntryPoint
        {
            get
            {
                return base.IsPropertySet("NoEntryPoint") && base.ActiveToolSwitches["NoEntryPoint"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("NoEntryPoint");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "No Entry Point";
                toolSwitch.Description = "The /NOENTRY option is required for creating a resource-only DLL.Use this option to prevent LINK from linking a reference to _main into the DLL.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/NOENTRY";
                toolSwitch.Name = "NoEntryPoint";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("NoEntryPoint", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool SetChecksum
        {
            get
            {
                return base.IsPropertySet("SetChecksum") && base.ActiveToolSwitches["SetChecksum"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SetChecksum");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Set Checksum";
                toolSwitch.Description = "The /RELEASE option sets the Checksum in the header of an .exe file.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/RELEASE";
                toolSwitch.Name = "SetChecksum";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SetChecksum", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string BaseAddress
        {
            get
            {
                if (base.IsPropertySet("BaseAddress"))
                {
                    return base.ActiveToolSwitches["BaseAddress"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BaseAddress");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Base Address";
                toolSwitch.Description = "Sets a base address for the program (/BASE:{address[,size] | @filename,key})";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "BaseAddress";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/BASE";
                base.ActiveToolSwitches.Add("BaseAddress", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool RandomizedBaseAddress
        {
            get
            {
                return base.IsPropertySet("RandomizedBaseAddress") && base.ActiveToolSwitches["RandomizedBaseAddress"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("RandomizedBaseAddress");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Randomized Base Address";
                toolSwitch.Description = "Randomized Base Address (/DYNAMICBASE[:NO])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DYNAMICBASE";
                toolSwitch.ReverseSwitchValue = "/DYNAMICBASE:NO";
                toolSwitch.Name = "RandomizedBaseAddress";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("RandomizedBaseAddress", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("DYNAMICBASE", "DYNAMICBASE:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("DYNAMICBASE:NO", "DYNAMICBASE"));
            }
        }
        public virtual bool FixedBaseAddress
        {
            get
            {
                return base.IsPropertySet("FixedBaseAddress") && base.ActiveToolSwitches["FixedBaseAddress"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("FixedBaseAddress");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Fixed Base Address";
                toolSwitch.Description = "Creates a program that can be loaded only at its preferred base address (/FIXED[:NO])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/FIXED";
                toolSwitch.ReverseSwitchValue = "/FIXED:NO";
                toolSwitch.Name = "FixedBaseAddress";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("FixedBaseAddress", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("FIXED", "FIXED:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("FIXED:NO", "FIXED"));
            }
        }
        public virtual bool DataExecutionPrevention
        {
            get
            {
                return base.IsPropertySet("DataExecutionPrevention") && base.ActiveToolSwitches["DataExecutionPrevention"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("DataExecutionPrevention");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Data Execution Prevention (DEP)";
                toolSwitch.Description = "Marks an executable as having been tested to be compatible with Windows Data Execution Prevention feature. (/NXCOMPAT[:NO])";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/NXCOMPAT";
                toolSwitch.ReverseSwitchValue = "/NXCOMPAT:NO";
                toolSwitch.Name = "DataExecutionPrevention";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("DataExecutionPrevention", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("NXCOMPAT", "NXCOMPAT:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("NXCOMPAT:NO", "NXCOMPAT"));
            }
        }
        public virtual bool TurnOffAssemblyGeneration
        {
            get
            {
                return base.IsPropertySet("TurnOffAssemblyGeneration") && base.ActiveToolSwitches["TurnOffAssemblyGeneration"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TurnOffAssemblyGeneration");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Turn Off Assembly Generation";
                toolSwitch.Description = "The /NOASSEMBLY option tells the linker to create an image for the current output file without a .NET Framework assembly.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/NOASSEMBLY";
                toolSwitch.Name = "TurnOffAssemblyGeneration";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("TurnOffAssemblyGeneration", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool SupportUnloadOfDelayLoadedDLL
        {
            get
            {
                return base.IsPropertySet("SupportUnloadOfDelayLoadedDLL") && base.ActiveToolSwitches["SupportUnloadOfDelayLoadedDLL"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SupportUnloadOfDelayLoadedDLL");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Unload delay loaded DLL";
                toolSwitch.Description = "The UNLOAD qualifier tells the delay-load helper function to support explicit unloading of the DLL. (/DELAY:UNLOAD)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DELAY:UNLOAD";
                toolSwitch.Name = "SupportUnloadOfDelayLoadedDLL";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SupportUnloadOfDelayLoadedDLL", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("DELAY:UNLOAD", "DELAY:NOBIND"));
            }
        }
        public virtual bool SupportNobindOfDelayLoadedDLL
        {
            get
            {
                return base.IsPropertySet("SupportNobindOfDelayLoadedDLL") && base.ActiveToolSwitches["SupportNobindOfDelayLoadedDLL"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SupportNobindOfDelayLoadedDLL");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Nobind delay loaded DLL";
                toolSwitch.Description = "The NOBIND qualifier tells the linker not to include a bindable IAT in the final image. The default is to create the bindable IAT for delay-loaded DLLs. (/DELAY:NOBIND)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DELAY:NOBIND";
                toolSwitch.Name = "SupportNobindOfDelayLoadedDLL";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("SupportNobindOfDelayLoadedDLL", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("DELAY:NOBIND", "DELAY:UNLOAD"));
            }
        }
        public virtual string ImportLibrary
        {
            get
            {
                if (base.IsPropertySet("ImportLibrary"))
                {
                    return base.ActiveToolSwitches["ImportLibrary"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ImportLibrary");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Import Library";
                toolSwitch.Description = "Overrides the default import library name (/IMPLIB:filename)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/IMPLIB";
                toolSwitch.Name = "ImportLibrary";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("ImportLibrary", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string MergeSections
        {
            get
            {
                if (base.IsPropertySet("MergeSections"))
                {
                    return base.ActiveToolSwitches["MergeSections"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MergeSections");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Merge Sections";
                toolSwitch.Description = "The /MERGE option combines the first section (from) with the second section (to), naming the resulting section to. For example, /merge:.rdata=.text.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "MergeSections";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "/MERGE";
                base.ActiveToolSwitches.Add("MergeSections", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string TargetMachine
        {
            get
            {
                if (base.IsPropertySet("TargetMachine"))
                {
                    return base.ActiveToolSwitches["TargetMachine"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("TargetMachine");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Target Machine";
                toolSwitch.Description = "The /MACHINE option specifies the target platform for the program.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "NotSet",
                        ""
                    },
                    new string[]
                    {
                        "MachineARM",
                        "/MACHINE:ARM"
                    },
                    new string[]
                    {
                        "MachineEBC",
                        "/MACHINE:EBC"
                    },
                    new string[]
                    {
                        "MachineIA64",
                        "/MACHINE:IA64"
                    },
                    new string[]
                    {
                        "MachineMIPS",
                        "/MACHINE:MIPS"
                    },
                    new string[]
                    {
                        "MachineMIPS16",
                        "/MACHINE:MIPS16"
                    },
                    new string[]
                    {
                        "MachineMIPSFPU",
                        "/MACHINE:MIPSFPU"
                    },
                    new string[]
                    {
                        "MachineMIPSFPU16",
                        "/MACHINE:MIPSFPU16"
                    },
                    new string[]
                    {
                        "MachineSH4",
                        "/MACHINE:SH4"
                    },
                    new string[]
                    {
                        "MachineTHUMB",
                        "/MACHINE:THUMB"
                    },
                    new string[]
                    {
                        "MachineX64",
                        "/MACHINE:X64"
                    },
                    new string[]
                    {
                        "MachineX86",
                        "/MACHINE:X86"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("TargetMachine", switchMap, value);
                toolSwitch.Name = "TargetMachine";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("TargetMachine", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool Profile
        {
            get
            {
                return base.IsPropertySet("Profile") && base.ActiveToolSwitches["Profile"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("Profile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Profile";
                toolSwitch.Description = "Produces an output file that can be used with the Performance Tools profiler. Requires GenerateDebugInformation (/DEBUG) to be set. (/PROFILE)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/PROFILE";
                toolSwitch.Name = "Profile";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("Profile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string CLRThreadAttribute
        {
            get
            {
                if (base.IsPropertySet("CLRThreadAttribute"))
                {
                    return base.ActiveToolSwitches["CLRThreadAttribute"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CLRThreadAttribute");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "CLR Thread Attribute";
                toolSwitch.Description = "Explicitly specify the threading attribute for the entry point of your CLR program.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "MTAThreadingAttribute",
                        "/CLRTHREADATTRIBUTE:MTA"
                    },
                    new string[]
                    {
                        "STAThreadingAttribute",
                        "/CLRTHREADATTRIBUTE:STA"
                    },
                    new string[]
                    {
                        "DefaultThreadingAttribute",
                        "/CLRTHREADATTRIBUTE:NONE"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CLRThreadAttribute", switchMap, value);
                toolSwitch.Name = "CLRThreadAttribute";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CLRThreadAttribute", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string CLRImageType
        {
            get
            {
                if (base.IsPropertySet("CLRImageType"))
                {
                    return base.ActiveToolSwitches["CLRImageType"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CLRImageType");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "CLR Image Type";
                toolSwitch.Description = "Sets the type (IJW, pure, or safe) of a CLR image.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "ForceIJWImage",
                        "/CLRIMAGETYPE:IJW"
                    },
                    new string[]
                    {
                        "ForcePureILImage",
                        "/CLRIMAGETYPE:PURE"
                    },
                    new string[]
                    {
                        "ForceSafeILImage",
                        "/CLRIMAGETYPE:SAFE"
                    },
                    new string[]
                    {
                        "Default",
                        ""
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CLRImageType", switchMap, value);
                toolSwitch.Name = "CLRImageType";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CLRImageType", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string KeyFile
        {
            get
            {
                if (base.IsPropertySet("KeyFile"))
                {
                    return base.ActiveToolSwitches["KeyFile"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("KeyFile");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Key File";
                toolSwitch.Description = "Specify key or key pair to sign an assembly. (/KEYFILE:filename)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/KEYFILE";
                toolSwitch.Name = "KeyFile";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("KeyFile", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string KeyContainer
        {
            get
            {
                if (base.IsPropertySet("KeyContainer"))
                {
                    return base.ActiveToolSwitches["KeyContainer"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("KeyContainer");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Key Container";
                toolSwitch.Description = "Specify a key container to sign an assembly. (/KEYCONTAINER:name)";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/KEYCONTAINER";
                toolSwitch.Name = "KeyContainer";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("KeyContainer", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool DelaySign
        {
            get
            {
                return base.IsPropertySet("DelaySign") && base.ActiveToolSwitches["DelaySign"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("DelaySign");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Delay Sign";
                toolSwitch.Description = "Partially sign an assembly. Use /DELAYSIGN if you only want to place the public key in the assembly. The default is /DELAYSIGN:NO.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DELAYSIGN";
                toolSwitch.ReverseSwitchValue = "/DELAYSIGN:NO";
                toolSwitch.Name = "DelaySign";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("DelaySign", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("DELAYSIGN", "DELAYSIGN:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("DELAYSIGN:NO", "DELAYSIGN"));
            }
        }
        public virtual bool CLRUnmanagedCodeCheck
        {
            get
            {
                return base.IsPropertySet("CLRUnmanagedCodeCheck") && base.ActiveToolSwitches["CLRUnmanagedCodeCheck"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CLRUnmanagedCodeCheck");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "CLR Unmanaged Code Check";
                toolSwitch.Description = "/CLRUNMANAGEDCODECHECK specifies whether the linker will apply SuppressUnmanagedCodeSecurityAttribute to linker-generated PInvoke calls from managed code into native DLLs.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/CLRUNMANAGEDCODECHECK";
                toolSwitch.ReverseSwitchValue = "/CLRUNMANAGEDCODECHECK:NO";
                toolSwitch.Name = "CLRUnmanagedCodeCheck";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("CLRUnmanagedCodeCheck", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("CLRUNMANAGEDCODECHECK", "CLRUNMANAGEDCODECHECK:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("CLRUNMANAGEDCODECHECK:NO", "CLRUNMANAGEDCODECHECK"));
            }
        }
        public virtual string LinkErrorReporting
        {
            get
            {
                if (base.IsPropertySet("LinkErrorReporting"))
                {
                    return base.ActiveToolSwitches["LinkErrorReporting"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LinkErrorReporting");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Error Reporting";
                toolSwitch.Description = "Allows you to provide internal compiler error (ICE) information directly to the Visual C++ team.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "PromptImmediately",
                        "/ERRORREPORT:PROMPT"
                    },
                    new string[]
                    {
                        "QueueForNextLogin",
                        "/ERRORREPORT:QUEUE"
                    },
                    new string[]
                    {
                        "SendErrorReport",
                        "/ERRORREPORT:SEND"
                    },
                    new string[]
                    {
                        "NoErrorReport",
                        "/ERRORREPORT:NONE"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("LinkErrorReporting", switchMap, value);
                toolSwitch.Name = "LinkErrorReporting";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("LinkErrorReporting", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual int SectionAlignment
        {
            get
            {
                if (base.IsPropertySet("SectionAlignment"))
                {
                    return base.ActiveToolSwitches["SectionAlignment"].Number;
                }
                return 0;
            }
            set
            {
                base.ActiveToolSwitches.Remove("SectionAlignment");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Integer);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "SectionAlignment";
                toolSwitch.Description = "The /ALIGN option specifies the alignment of each section within the linear address space of the program. The number argument is in bytes and must be a power of two.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                if (base.ValidateInteger("/ALIGN", -2147483648, 2147483647, value))
                {
                    toolSwitch.IsValid = true;
                }
                else
                {
                    toolSwitch.IsValid = false;
                }
                toolSwitch.Name = "SectionAlignment";
                toolSwitch.SwitchValue = "/ALIGN";
                toolSwitch.Number = value;
                base.ActiveToolSwitches.Add("SectionAlignment", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string CLRSupportLastError
        {
            get
            {
                if (base.IsPropertySet("CLRSupportLastError"))
                {
                    return base.ActiveToolSwitches["CLRSupportLastError"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("CLRSupportLastError");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Preserve Last Error Code for PInvoke Calls";
                toolSwitch.Description = "/CLRSUPPORTLASTERROR, which is on by default, preserves the last error code of functions called through the P/Invoke mechanism, which allows you to call native functions in DLLS, from code compiled with /clr.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "Enabled",
                        "/CLRSupportLastError"
                    },
                    new string[]
                    {
                        "Disabled",
                        "/CLRSupportLastError:NO"
                    },
                    new string[]
                    {
                        "SystemDlls",
                        "/CLRSupportLastError:SYSTEMDLL"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("CLRSupportLastError", switchMap, value);
                toolSwitch.Name = "CLRSupportLastError";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("CLRSupportLastError", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool ImageHasSafeExceptionHandlers
        {
            get
            {
                return base.IsPropertySet("ImageHasSafeExceptionHandlers") && base.ActiveToolSwitches["ImageHasSafeExceptionHandlers"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("ImageHasSafeExceptionHandlers");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "Image Has Safe Exception Handlers";
                toolSwitch.Description = "When /SAFESEH is specified, the linker will only produce an image if it can also produce a table of the image's safe exception handlers. This table specifies for the operating system which exception handlers are valid for the image.";
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/SAFESEH";
                toolSwitch.ReverseSwitchValue = "/SAFESEH:NO";
                toolSwitch.Name = "ImageHasSafeExceptionHandlers";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("ImageHasSafeExceptionHandlers", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("SAFESEH", "SAFESEH:NO"));
                toolSwitch.Overrides.AddLast(new KeyValuePair<string, string>("SAFESEH:NO", "SAFESEH"));
            }
        }
        public virtual bool LinkDLL
        {
            get
            {
                return base.IsPropertySet("LinkDLL") && base.ActiveToolSwitches["LinkDLL"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("LinkDLL");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "/DLL";
                toolSwitch.Name = "LinkDLL";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("LinkDLL", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        [Required]
        public virtual ITaskItem[] Sources
        {
            get
            {
                if (base.IsPropertySet("Sources"))
                {
                    //for (int k = 0; k < base.ActiveToolSwitches["Sources"].TaskItemArray.Length; k++)
                    //{
                    //    if (base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec.Contains("matrix_multiply_amp.obj"))
                    //    {
                    //        base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec = "matrix_multiply_amp.fatobj";
                    //        break;
                    //    }
                    //}
                    return base.ActiveToolSwitches["Sources"].TaskItemArray;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("Sources");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.ITaskItemArray);
                toolSwitch.Separator = "\r\n";
                toolSwitch.Required = true;
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.TaskItemArray = value;
                base.ActiveToolSwitches.Add("Sources", toolSwitch);
                //for (int k = 0; k < base.ActiveToolSwitches["Sources"].TaskItemArray.Length; k++)
                //    if (base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec.EndsWith(".obj"))
                //    {
                //        string item = base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec;
                //        int i_len = item.Length;
                //        item = item.Remove(i_len - 4);
                //        base.ActiveToolSwitches["Sources"].TaskItemArray[k].ItemSpec = item + ".fatobj";
                //    }
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool BuildingInIDE
        {
            get
            {
                return base.IsPropertySet("BuildingInIDE") && base.ActiveToolSwitches["BuildingInIDE"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("BuildingInIDE");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "BuildingInIDE";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("BuildingInIDE", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string UACExecutionLevel
        {
            get
            {
                if (base.IsPropertySet("UACExecutionLevel"))
                {
                    return base.ActiveToolSwitches["UACExecutionLevel"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UACExecutionLevel");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "UAC Execution Level";
                toolSwitch.Description = "Specifies the requested execution level for the application when running with User Account Control.  (/MANIFESTUAC:level=[value])";
                toolSwitch.Parents.AddLast("EnableUAC");
                toolSwitch.ArgumentRelationList = new ArrayList();
                string[][] switchMap = new string[][]
                {
                    new string[]
                    {
                        "AsInvoker",
                        "level='asInvoker'"
                    },
                    new string[]
                    {
                        "HighestAvailable",
                        "level='highestAvailable'"
                    },
                    new string[]
                    {
                        "RequireAdministrator",
                        "level='requireAdministrator'"
                    }
                };
                toolSwitch.SwitchValue = base.ReadSwitchMap("UACExecutionLevel", switchMap, value);
                toolSwitch.Name = "UACExecutionLevel";
                toolSwitch.Value = value;
                toolSwitch.MultiValues = true;
                base.ActiveToolSwitches.Add("UACExecutionLevel", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual bool UACUIAccess
        {
            get
            {
                return base.IsPropertySet("UACUIAccess") && base.ActiveToolSwitches["UACUIAccess"].BooleanValue;
            }
            set
            {
                base.ActiveToolSwitches.Remove("UACUIAccess");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);
                toolSwitch.DisplayName = "UAC Bypass UI Protection";
                toolSwitch.Description = "UAC Bypass UI Protection : Specifies whether or not to bypass user interface protection levels for other windows on the desktop.  Set this property to 'Yes' only for accessibility applications.  (/MANIFESTUAC:uiAccess=[true | false])";
                toolSwitch.Parents.AddLast("EnableUAC");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.SwitchValue = "uiAccess='true'";
                toolSwitch.ReverseSwitchValue = "uiAccess='false'";
                toolSwitch.Name = "UACUIAccess";
                toolSwitch.BooleanValue = value;
                base.ActiveToolSwitches.Add("UACUIAccess", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string MapFileName
        {
            get
            {
                if (base.IsPropertySet("MapFileName"))
                {
                    return base.ActiveToolSwitches["MapFileName"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MapFileName");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);
                toolSwitch.Separator = ":";
                toolSwitch.DisplayName = "Map File Name";
                toolSwitch.Description = "A user-specified name for the mapfile. It replaces the default name.";
                toolSwitch.Parents.AddLast("GenerateMapFile");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "MapFileName";
                toolSwitch.Value = value;
                base.ActiveToolSwitches.Add("MapFileName", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string MinimumRequiredVersion
        {
            get
            {
                if (base.IsPropertySet("MinimumRequiredVersion"))
                {
                    return base.ActiveToolSwitches["MinimumRequiredVersion"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("MinimumRequiredVersion");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.Separator = ",";
                toolSwitch.DisplayName = "Minimum Required Version";
                toolSwitch.Description = "Specify the minimum required version of the subsystem. The arguments are decimal numbers in the range 0 through 65,535.";
                toolSwitch.Parents.AddLast("SubSystem");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "MinimumRequiredVersion";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "";
                base.ActiveToolSwitches.Add("MinimumRequiredVersion", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string HeapCommitSize
        {
            get
            {
                if (base.IsPropertySet("HeapCommitSize"))
                {
                    return base.ActiveToolSwitches["HeapCommitSize"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("HeapCommitSize");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Heap Commit Size";
                toolSwitch.Description = "Specifies total heap allocation size in physical memory. Default is 4KB.    (/HEAP:reserve,commit)";
                toolSwitch.Parents.AddLast("HeapReserveSize");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "HeapCommitSize";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "";
                base.ActiveToolSwitches.Add("HeapCommitSize", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        public virtual string StackCommitSize
        {
            get
            {
                if (base.IsPropertySet("StackCommitSize"))
                {
                    return base.ActiveToolSwitches["StackCommitSize"].Value;
                }
                return null;
            }
            set
            {
                base.ActiveToolSwitches.Remove("StackCommitSize");
                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);
                toolSwitch.DisplayName = "Stack Commit Size";
                toolSwitch.Description = "Specifies the total stack allocation size in physical memory. Default is 4KB.     (/STACK:reserve,commit)";
                toolSwitch.Parents.AddLast("StackReserveSize");
                toolSwitch.ArgumentRelationList = new ArrayList();
                toolSwitch.Name = "StackCommitSize";
                toolSwitch.Value = value;
                toolSwitch.SwitchValue = "";
                base.ActiveToolSwitches.Add("StackCommitSize", toolSwitch);
                base.AddActiveSwitchToolValue(toolSwitch);
            }
        }
        protected override ArrayList SwitchOrderList
        {
            get
            {
                return this.switchOrderList;
            }
        }
        protected override bool UseUnicodeOutput
        {
            get
            {
                return this.BuildingInIDE;
            }
        }
        protected override bool MaintainCompositeRootingMarkers
        {
            get
            {
                return true;
            }
        }
        public override bool AttributeFileTracking
        {
            get
            {
                return true;
            }
        }
        [Output]
        public string[] ObjectFiles
        {
            get
            {
//                for (int k = 0; k < this.objectFiles.Length; k++)
//                {
//                    if (this.objectFiles[k].Contains("matrix_multiply_amp.obj"))
//                    {
//                        this.objectFiles.SetValue("matrix_multiply_amp.fatobj", k);
//                        break;
//                    }
//                }
                return this.objectFiles;
            }
            set
            {
                this.objectFiles = value;
            }
        }
        [Output]
        public ITaskItem[] PreprocessOutput
        {
            get
            {
                return this.preprocessOutput;
            }
            set
            {
                this.preprocessOutput = value;
            }
        }
        protected override string[] ReadTLogNames
        {
            get
            {
                return new string[]
                {
                    "link.read.*.tlog",
                    "link.*.read.*.tlog",
                    "link-cvtres.read.*.tlog",
                    "link.*-cvtres.read.*.tlog",
                    "link-*.read.*.tlog"
                };
            }
        }
        protected override string[] WriteTLogNames
        {
            get
            {
                return new string[]
                {
                    "link.write.*.tlog",
                    "link.*.write.*.tlog",
                    "link-cvtres.write.*.tlog",
                    "link.*-cvtres.write.*.tlog",
                    "link-*.write.*.tlog"
                };
            }
        }
        protected override string CommandTLogName
        {
            get
            {
                return "link.command.1.tlog";
            }
        }
        protected override string TrackerIntermediateDirectory
        {
            get
            {
                if (this.TrackerLogDirectory != null)
                {
                    return this.TrackerLogDirectory;
                }
                return string.Empty;
            }
        }
        protected override ITaskItem[] TrackedInputFiles
        {
            get
            {
                return this.Sources;
            }
        }
        public AALink()
            : base(new ResourceManager("AMD.Build.AACLTasks.Resources", Assembly.GetExecutingAssembly()))
        {
            this.switchOrderList = new ArrayList();
            this.switchOrderList.Add("OutputFile");
            this.switchOrderList.Add("ShowProgress");
            this.switchOrderList.Add("Version");
            this.switchOrderList.Add("LinkIncremental");
            this.switchOrderList.Add("SuppressStartupBanner");
            this.switchOrderList.Add("IgnoreImportLibrary");
            this.switchOrderList.Add("RegisterOutput");
            this.switchOrderList.Add("PerUserRedirection");
            this.switchOrderList.Add("AdditionalLibraryDirectories");
            this.switchOrderList.Add("LinkLibraryDependencies");
            this.switchOrderList.Add("UseLibraryDependencyInputs");
            this.switchOrderList.Add("LinkStatus");
            this.switchOrderList.Add("PreventDllBinding");
            this.switchOrderList.Add("TreatLinkerWarningAsErrors");
            this.switchOrderList.Add("ForceFileOutput");
            this.switchOrderList.Add("CreateHotPatchableImage");
            this.switchOrderList.Add("SpecifySectionAttributes");
            this.switchOrderList.Add("MSDOSStubFileName");
            this.switchOrderList.Add("TrackerLogDirectory");
            this.switchOrderList.Add("AdditionalDependencies");
            this.switchOrderList.Add("IgnoreAllDefaultLibraries");
            this.switchOrderList.Add("IgnoreSpecificDefaultLibraries");
            this.switchOrderList.Add("ModuleDefinitionFile");
            this.switchOrderList.Add("AddModuleNamesToAssembly");
            this.switchOrderList.Add("EmbedManagedResourceFile");
            this.switchOrderList.Add("ForceSymbolReferences");
            this.switchOrderList.Add("DelayLoadDLLs");
            this.switchOrderList.Add("AssemblyLinkResource");
            this.switchOrderList.Add("GenerateManifest");
            this.switchOrderList.Add("ManifestFile");
            this.switchOrderList.Add("AdditionalManifestDependencies");
            this.switchOrderList.Add("AllowIsolation");
            this.switchOrderList.Add("EnableUAC");
            this.switchOrderList.Add("UACExecutionLevel");
            this.switchOrderList.Add("UACUIAccess");
            this.switchOrderList.Add("GenerateDebugInformation");
            this.switchOrderList.Add("ProgramDatabaseFile");
            this.switchOrderList.Add("StripPrivateSymbols");
            this.switchOrderList.Add("GenerateMapFile");
            this.switchOrderList.Add("MapFileName");
            this.switchOrderList.Add("MapExports");
            this.switchOrderList.Add("AssemblyDebug");
            this.switchOrderList.Add("SubSystem");
            this.switchOrderList.Add("MinimumRequiredVersion");
            this.switchOrderList.Add("HeapReserveSize");
            this.switchOrderList.Add("HeapCommitSize");
            this.switchOrderList.Add("StackReserveSize");
            this.switchOrderList.Add("StackCommitSize");
            this.switchOrderList.Add("LargeAddressAware");
            this.switchOrderList.Add("TerminalServerAware");
            this.switchOrderList.Add("SwapRunFromCD");
            this.switchOrderList.Add("SwapRunFromNET");
            this.switchOrderList.Add("Driver");
            this.switchOrderList.Add("OptimizeReferences");
            this.switchOrderList.Add("EnableCOMDATFolding");
            this.switchOrderList.Add("FunctionOrder");
            this.switchOrderList.Add("ProfileGuidedDatabase");
            this.switchOrderList.Add("LinkTimeCodeGeneration");
            this.switchOrderList.Add("MidlCommandFile");
            this.switchOrderList.Add("IgnoreEmbeddedIDL");
            this.switchOrderList.Add("MergedIDLBaseFileName");
            this.switchOrderList.Add("TypeLibraryFile");
            this.switchOrderList.Add("TypeLibraryResourceID");
            this.switchOrderList.Add("EntryPointSymbol");
            this.switchOrderList.Add("NoEntryPoint");
            this.switchOrderList.Add("SetChecksum");
            this.switchOrderList.Add("BaseAddress");
            this.switchOrderList.Add("RandomizedBaseAddress");
            this.switchOrderList.Add("FixedBaseAddress");
            this.switchOrderList.Add("DataExecutionPrevention");
            this.switchOrderList.Add("TurnOffAssemblyGeneration");
            this.switchOrderList.Add("SupportUnloadOfDelayLoadedDLL");
            this.switchOrderList.Add("SupportNobindOfDelayLoadedDLL");
            this.switchOrderList.Add("ImportLibrary");
            this.switchOrderList.Add("MergeSections");
            this.switchOrderList.Add("TargetMachine");
            this.switchOrderList.Add("Profile");
            this.switchOrderList.Add("CLRThreadAttribute");
            this.switchOrderList.Add("CLRImageType");
            this.switchOrderList.Add("KeepIntermediateFiles");
            this.switchOrderList.Add("KeyFile");
            this.switchOrderList.Add("KeyContainer");
            this.switchOrderList.Add("DelaySign");
            this.switchOrderList.Add("CLRUnmanagedCodeCheck");
            this.switchOrderList.Add("LinkErrorReporting");
            this.switchOrderList.Add("SectionAlignment");
            this.switchOrderList.Add("CLRSupportLastError");
            this.switchOrderList.Add("ImageHasSafeExceptionHandlers");
            this.switchOrderList.Add("LinkDLL");
            this.switchOrderList.Add("Sources");
            this.switchOrderList.Add("AdditionalOptions");
            this.switchOrderList.Add("BuildingInIDE");
        }
        protected override void ValidateRelations()
        {
            if (!base.IsSwitchValueSet("ASSEMBLYMODULE"))
            {
                base.RemoveSwitchToolBasedOnValue("ASSEMBLYMODULEMAP");
            }
            if (!base.IsSwitchValueSet("LTCG"))
            {
                base.RemoveSwitchToolBasedOnValue("B2");
            }
        }
        public override string ApplyPrecompareCommandFilter(string cmdString)
        {
            string text = cmdString;
            int num;
            if ((num = text.IndexOf("/ERRORREPORT:")) >= 0)
            {
                int num2;
                if ((num2 = text.IndexOf(' ', num)) == -1)
                {
                    num2 = text.Length;
                }
                else
                {
                    num2++;
                }
                text = text.Remove(num, num2 - num);
            }
            return text;
        }
        protected override string GenerateCommandLineCommands()
        {
            if (base.IsPropertySet("LinkErrorReporting"))
            {
                CommandLineBuilder commandLineBuilder = new CommandLineBuilder();
                base.GenerateCommandsAccordingToType(commandLineBuilder, base.ActiveToolSwitches["LinkErrorReporting"], false);
                return commandLineBuilder.ToString();
            }
            return string.Empty;
        }
        protected override void PostProcessSwitchList()
        {
            if (base.IsPropertySet("BaseAddress"))
            {
                string text = base.ActiveToolSwitches["BaseAddress"].Value.TrimStart(new char[0]);
                long num = 0L;
                if (!text.StartsWith("0x", StringComparison.OrdinalIgnoreCase) && !long.TryParse(text, out num) && !text.StartsWith("@", StringComparison.OrdinalIgnoreCase) && !text.StartsWith("\"@", StringComparison.OrdinalIgnoreCase))
                {
                    base.ActiveToolSwitches["BaseAddress"].Separator = ":@";
                }
            }
        }
        protected override string GenerateResponseFileCommands()
        {
            return base.GenerateResponseFileCommandsExceptSwitches(new string[]
            {
                "LinkErrorReporting"
            });
        }
        protected override bool ForcedRebuildRequired()
        {
            bool flag = false;
            if (this.GenerateDebugInformation && this.ProgramDatabaseFile != null)
            {
                flag = !File.Exists(this.ProgramDatabaseFile);
            }
            return flag || base.ForcedRebuildRequired();
        }
        protected override void AddTaskSpecificOutputs(ITaskItem[] sources, CanonicalTrackedOutputFiles compactOutputs)
        {
            if (this.GenerateDebugInformation && this.ProgramDatabaseFile != null)
            {
                string sourceKey = FileTracker.FormatRootingMarker(sources);
                compactOutputs.AddComputedOutputForSourceRoot(sourceKey, this.ProgramDatabaseFile);
            }
        }
        protected override void RemoveTaskSpecificOutputs(CanonicalTrackedOutputFiles compactOutputs)
        {
            string text;
            if (base.IsPropertySet("ImportLibrary"))
            {
                text = this.ImportLibrary;
            }
            else
            {
                if (!base.IsPropertySet("OutputFile"))
                {
                    return;
                }
                text = Path.ChangeExtension(this.OutputFile, ".LIB");
            }
            string itemSpec = Path.ChangeExtension(text, ".EXP");
            TaskItem dependencyToRemove = new TaskItem(text);
            TaskItem dependencyToRemove2 = new TaskItem(itemSpec);
            compactOutputs.RemoveDependencyFromEntry(this.Sources, dependencyToRemove);
            compactOutputs.RemoveDependencyFromEntry(this.Sources, dependencyToRemove2);
        }
    }
}
