//===- amdopt.inc - AMD specific code to opt.cpp --------------------------===//
//
// Copyright (c) 2012, Advanced Micro Devices, Inc.
// All rights reserved.
//
//===----------------------------------------------------------------------===//

#include "llvm/LLVMContext.h"
#include "llvm/AMDLLVMContextHook.h"
#include "llvm/ADT/Triple.h"
#include <string>
#include <set>

static cl::opt<bool>
DisableAMDOpts("disable-amd-opts",
	       cl::desc("Disable AMD optimizations (restore default opt behavior)"));

static cl::opt<bool>
EnableWholeProgram("whole", cl::desc("Enable whole program mode"));

static cl::opt<bool>
EnableGPUOpt("gpu", cl::desc("Enable optimization for GPU"));

static cl::opt<unsigned>
OptLICM("en-licm", cl::init(1), cl::NotHidden, cl::desc("Enable/Disable LICM"));

static cl::opt<unsigned>
OptLiveness("liveness", cl::init(1), cl::NotHidden,
  cl::desc("Enable/Disable Opt Liveness Analysis"));

static cl::opt<unsigned>
OptPrintLiveness("prt-opt-liveness", cl::init(0), cl::NotHidden,
   cl::desc("Enable/Disable printing liveness info at the end of opt"));

static cl::opt<unsigned>
OptSimplifyLibCall("slc", cl::init(1), cl::NotHidden,
   cl::desc("Enable/Disable optimizations to simplify lib calls"
            "(enabled by default)"));

static cl::opt<unsigned>
EnableFDiv2FMul("fdiv2fmul", cl::init(1), cl::NotHidden,
   cl::desc("Enable/Disable float f/c ==> f * (1.0f/c) for GPU"
            "(enabled by default)"));

static cl::opt<unsigned>
OptMem2reg("en-mem2reg", cl::init(1), cl::NotHidden,
   cl::desc("Enable/Disable mem2reg pass (enabled by default)"));

static cl::opt<unsigned>
UseJIT("use-jit", cl::init(0), cl::NotHidden,
  cl::desc("Turn on/off JIT (off by default)"));

static cl::opt<unsigned>
LUThreshold("lu-threshold", cl::init(100), cl::NotHidden,
  cl::desc("Set loop unroll threshold"));

static cl::opt<unsigned>
LUCount("lu-count", cl::init(0), cl::NotHidden,
  cl::desc("Set loop unroll count"));

static cl::opt<unsigned>
LUAllowPartial("lu-allow-partial", cl::init(1), cl::NotHidden,
  cl::desc("Turn on/off partial unroll (on by default)"));

static cl::opt<unsigned>
SRThreshold("srt", cl::init(128), cl::NotHidden,
  cl::desc("Set Scalar Replacement threshold"));

static cl::opt<unsigned>
OptMemCombineMaxVecGen("mc-max-vec", cl::init(64), cl::NotHidden,
  cl::desc("Set Maximum width (#bytes) of vector loads/stores generated by"
           "memory access combining(MAC). Setting it to 1 disables MAC"));

static const char* amdRTFuns[] = {
  "__amdrt_div_i64",
  "__amdrt_div_u64",
  "__amdrt_mod_i64",
  "__amdrt_mod_u64",
  "__amdrt_cvt_f64_to_u64",
  "__amdrt_cvt_f32_to_u64"
};

static std::set<std::string> *getAmdRtFunctions()
{
  std::set<std::string> *result = new std::set<std::string>();
  for (size_t i = 0; i < sizeof(amdRTFuns)/sizeof(amdRTFuns[0]); ++i)
    result->insert(amdRTFuns[i]);
  return result;
}

void AMDSetContextHook(LLVMContext* pContext, AMDLLVMContextHook* pAmdHook)
{
  pAmdHook->amdrtFunctions = ((UseJIT != 0) ? getAmdRtFunctions() : NULL);

  AMDOptions *amdopts = &(pAmdHook->amdoptions);

  amdopts->IsGPU = EnableGPUOpt;
  amdopts->UnsafeMathOpt = EnableUnsafeFPMath;
  amdopts->WholeProgram = EnableWholeProgram;
  amdopts->OptLiveness = (OptLiveness != 0);
  amdopts->OptPrintLiveness = (OptPrintLiveness != 0);
  amdopts->NumAvailGPRs = 0;
  amdopts->OptSimplifyLibCall = (OptSimplifyLibCall != 0);
  amdopts->EnableFDiv2FMul = (EnableFDiv2FMul != 0);
  amdopts->OptMem2reg = (OptMem2reg != 0);
  amdopts->UseJIT = (UseJIT != 0);
  amdopts->OptLICM = (OptLICM != 0);
  amdopts->LUThreshold = LUThreshold;
  amdopts->LUCount = LUCount;
  amdopts->LUAllowPartial = LUAllowPartial;
  amdopts->UnrollScratchThreshold = -1;
  amdopts->OptMemCombineMaxVecGen = OptMemCombineMaxVecGen;
  amdopts->SRThreshold = SRThreshold;

  pContext->setAMDLLVMContextHook(pAmdHook);
}

bool AMDAddOptimizationPasses(Module *M, PassManagerBase &MPM,FunctionPassManager &FPM,
                              unsigned OptLevel)
{
  PassManagerBuilder Builder;
  Builder.OptLevel = OptLevel;

  if (DisableAMDOpts) {
    return false;
  }

  // Apply AMD default options (to match runtime behavior)
  const char* amd_argv[] = { "",
                             "-loop-unswitch-threshold=0",
                             "-binomial-coefficient-limit-bitwidth=64"
  };
  size_t amd_args = sizeof(amd_argv) / sizeof(amd_argv[0]);
  cl::ParseCommandLineOptions(amd_args, (char**)amd_argv, "OpenCL default opt options");

  if (DisableInline) {
    // No inlining pass
  } else if (EnableGPUOpt) {
    if (HLC_Experimental_Enable_Calls) {
      HLC_Disable_Amd_Inline_All = true;
    }
    if (HLC_Force_Always_Inliner_Pass) {
      Builder.Inliner = createAlwaysInlinerPass();
    } else {
      Builder.Inliner = createFunctionInliningPass(500);
    }
  } else if (OptLevel > 1) {
    unsigned Threshold = 225;
    if (OptLevel > 2)
      Threshold = 275;
    // Don't do inlining (including createAlwaysInlinerPass()) if OptimizationLevel
    // is zero becaue we are generating code for -g
    Builder.Inliner = createFunctionInliningPass(Threshold);
  }
  Builder.SizeLevel = 0;
  Builder.DisableUnitAtATime = false;
  Builder.DisableUnrollLoops = OptLevel == 0;
  Triple::ArchType Arch = Triple(M->getTargetTriple()).getArch();
  Builder.DisableSimplifyLibCalls = (Arch != Triple::hsail && Arch != Triple::hsail_64);

  LLVMContext& gContext = getGlobalContext();
  Builder.AMDpopulateFunctionPassManager(FPM, &gContext);
  Builder.AMDpopulateModulePassManager(MPM, &gContext, M);

  return true;
}
