//===-- HSAILTestGenNavigator.cpp - HSAIL Test Generator Navigator -----------===//
//
//===----------------------------------------------------------------------===//
//
// HSAIL Test Generator Navigator. (C) 2012 AMD Inc. All rights reserved.
//
//===----------------------------------------------------------------------===//

#include "HSAILTestGenFilter.h"

#include "HSAILValidatorBase.h"
#include "HSAILTestGenOptions.h"
#include "HSAILTestGenNavigator.h"
#include "HSAILTestGenUtilities.h"
#include "HSAILUtilities.h"
#include "HSAILItems.h"
#include "Brig.h"

#include <algorithm>
#include <cctype>
#include <sstream>
#include <iomanip> 

using std::string;
using std::vector;
using std::ostringstream;

using HSAIL_ASM::Inst;
using HSAIL_ASM::InstBasic;
using HSAIL_ASM::InstAtomic;
using HSAIL_ASM::InstLane;
using HSAIL_ASM::InstCmp;
using HSAIL_ASM::InstCvt;
using HSAIL_ASM::InstAddr;
using HSAIL_ASM::InstImage;
using HSAIL_ASM::InstMem;
using HSAIL_ASM::InstMod;
using HSAIL_ASM::InstBr;
using HSAIL_ASM::InstSourceType;
using HSAIL_ASM::InstSeg;
using HSAIL_ASM::InstMemFence;
using HSAIL_ASM::InstSegCvt;
using HSAIL_ASM::InstSignal;
using HSAIL_ASM::InstQueue;
using HSAIL_ASM::InstQueryImage;
using HSAIL_ASM::InstQuerySampler;

using HSAIL_ASM::Operand;
using HSAIL_ASM::OperandReg;

using HSAIL_ASM::PropValidator;

using HSAIL_ASM::opcode2str;
using HSAIL_ASM::isPackedType;
using HSAIL_ASM::getSrcType;
using HSAIL_ASM::getType;

// ============================================================================
// ============================================================================

namespace TESTGEN {

//=============================================================================
//=============================================================================
//=============================================================================

enum Category
{
    C_ARITHMETIC = 0,
    C_MOVE,
    C_ATOMIC_MEMORY,
    C_MEMORY,
    C_IMAGE,
    C_SYNC,
    C_MISC,
    C_BRANCH,
    C_GCN_ARITHMETIC,
    C_GCN_ATOMIC_MEMORY,
    C_GCN_MEMORY,
    C_GCN_MISC,

    C_MAXID
};

static const char* categoryName[] =
{
    "arith",
    "arith",
    "mem/atomic",
    "mem/nonatomic",
    "image/atomic",
    "image/nonatomic",
    "sync",
    "special",
    "branch",
    "gcn/arith",
    "gcn/mem/atomic",
    "gcn/mem/nonatomic",
    "gcn/special"
};

static const char* operandName[] =
{
    "operand0",
    "operand1",
    "operand2",
    "operand3",
    "operand4",
};

struct CategoryDesc 
{
    unsigned categoryId;
    unsigned instOpcode;

    bool operator<(const CategoryDesc& c) const { return this->instOpcode < c.instOpcode; }
};

//=============================================================================
// Mapping of opcodes to test categories (autogenerated from HDL description)

#define CATEGORIES
#include "HSAILTestGen_gen.hpp"
#undef CATEGORIES

//=============================================================================
//=============================================================================
//=============================================================================

#define DEFAULT_PROP_VAL_NAME    ("default")
#define NONDEFAULT_PROP_VAL_NAME ("nondefault")

class TestGenNavigatorImpl
{
    //==========================================================================
private:
    static const unsigned OPCODE_NONE = 0xFFFFFFFF;

    //==========================================================================
private:
    CategoryDesc*  instCategoryTab; // mapping of opcodes to category (sorted by opcode)
    TestGenFilter  filter;          // test filtering component

    //==========================================================================
private:
    Inst           testInst;        // test instruction generated for the current test
    vector<string> testProps;       // properties of the current test
    unsigned       prevOpcode;      // opcode of the previously generated test (if any)

    //==========================================================================
public:
    TestGenNavigatorImpl() : instCategoryTab(0), prevOpcode(OPCODE_NONE) {}
    ~TestGenNavigatorImpl() { delete[] instCategoryTab; }

    //==========================================================================
public:
    bool isOpcodeEnabled(unsigned opcode)
    { 
        return filter.isOpcodeEnabled(opcode);
    }
    
    bool startTest(Inst inst)
    { 
        clean();
        testInst = inst;
        registerTestProps(inst); 
        if (!filter.isTestEnabled(testProps)) return false;
        if (hasPackedOperand(inst)  && (dataType & DATA_TYPE_PACKED) == 0)  return false;
        if (!hasPackedOperand(inst) && (dataType & DATA_TYPE_REGULAR) == 0) return false;
        return true;
    }

    string getTestTags(unsigned testIdx, bool isFullDesc = true)
    { 
        ostringstream s;

        if (isFullDesc)              // dump full test description
        {
            unsigned baseCategoryId = getBaseCategoryId(testInst);
            string relPath = getCategoryName(testInst, baseCategoryId, '/') + "/" + getInstName();
            s << relPath << ":" << std::setw(5) << std::setfill('0') << testIdx << " all";
            for (unsigned i = 0; i < testProps.size(); ++i) 
            {
                s << ',' << testProps[i];
            }
            s << getCategoryTags(testInst, baseCategoryId) << "\n";
        }
        else                            // dump only list of opcodes
        {
            if (prevOpcode == OPCODE_NONE || prevOpcode != getOpcode()) 
            {
                prevOpcode = getOpcode();
                s << opcode2str(getOpcode()) << "\n";
            }
        }

        return s.str();
    }

    string getRelTestPath()
    {
        return getCategoryName(testInst, getBaseCategoryId(testInst), '/') + "/" + getInstName();
    }

    static const char* val2str(unsigned propId, unsigned propVal) { return PropValidator::val2str(propId, propVal); }

    //==========================================================================
private:

    bool hasPackedOperand(Inst inst) 
    {
        return isPackedType(getType(inst)) || isPackedType(getSrcType(inst));
    }

    void clean()              { testInst = Inst(); }
    const char* getInstName() { return val2str(PROP_OPCODE, testInst.opcode()); }
    unsigned getOpcode()      { return testInst.opcode(); }

    //==========================================================================
private:
    void visitProp(Inst inst, unsigned propId, unsigned propVal)
    {
        if (propId == PROP_EQUIVCLASS)
        {
            ostringstream s;
            s << propVal;
            addProp(makeProp(propId, s.str()));
            addProp(makeDefaultProp(propId, propVal == 0));
        }
        else if (propId == PROP_WIDTH)
        {
            addProp(makeProp(propId, propVal));
            addProp(makeDefaultProp(propId, propVal == getDefWidth(inst, machineModel, profile)));
        }
        else
        {
            addProp(makeProp(propId, propVal));
        }
    }

    void addProp(const char* propName, string propVal) { addProp(propName, propVal.c_str()); }

    void addProp(const char* propName, const char* propVal, const char* defaultVal = "none")
    {
        if (!propVal || strlen(propVal) == 0) propVal = defaultVal;
        addProp(string(propName) + "=" + propVal);
    }

    void addProp(string prop)
    {
        testProps.push_back(prop);
    }

    void addProp(unsigned propId, unsigned propVal)
    {
        addProp(makeProp(propId, propVal));
    }

    string makeProp(unsigned propId, string propVal)
    {
        return PropValidator::prop2key(propId) + string("=") + propVal;
    }

    string makeProp(unsigned propId, unsigned propVal)
    {
        return makeProp(propId, PropValidator::val2str(propId, propVal));
    }

    string makeDefaultProp(unsigned propId, bool isDefault)
    {
        return makeProp(propId, isDefault? DEFAULT_PROP_VAL_NAME : NONDEFAULT_PROP_VAL_NAME);
    }

    //==========================================================================
private:

    void registerOperandProps(unsigned i, Operand opr)
    {
        if (!opr) 
        {
            addProp(operandName[i], "null");
            return;
        }

        addProp(operandName[i], PropValidator::operandKind2str(opr.kind()));
    }

    void registerOperandProps(Inst inst)
    {
        for (int i = 0; i < inst.operands().size(); ++i)
        {
            registerOperandProps(i, inst.operand(i));
        }
    }

    void registerTestProps(Inst inst)
    {
        testProps.clear();
        visitBrigProps(inst);
        registerOperandProps(inst);
    }

    //==========================================================================
    //==========================================================================
    //==========================================================================
    // Registration of test properties (autogenerated)
private:

#include "HSAILBrigPropsVisitor_gen.hpp"

    //==========================================================================
    //==========================================================================
    //==========================================================================
private:
    void initBaseCategoryTab();
    unsigned getBaseCategoryId(Inst inst);
    unsigned getBaseCategoriesNum() { return sizeof(baseCategories) / sizeof(CategoryDesc); }

    //==========================================================================
    //==========================================================================
    //==========================================================================
private:

    static string getCategoryName(Inst inst, unsigned category, char delim)
    {
        assert(category < C_MAXID);
        string res = categoryName[category];

        switch(category)
        {
        case C_ARITHMETIC:      // packed, type
        case C_GCN_ARITHMETIC:  // type
            if (getPacking(inst) != Brig::BRIG_PACK_NONE || HSAIL_ASM::isPackedType(getType(inst)))
            {
                res += getPackedCategory(inst);
            }
            else
            {
                res += getTypeCategory(inst);
            }
            break;
        case C_MOVE: {          // type, vector
            string v = getVectorCategory(inst);
            res += (v.length() > 0)? v : getTypeCategory(inst);
            }
            break;
        case C_ATOMIC_MEMORY:
        case C_GCN_ATOMIC_MEMORY:
            break;
        case C_MEMORY:          // vector
        case C_GCN_MEMORY:      // vector
            res += getVectorCategory(inst);
            break;
        case C_BRANCH:          // direct, indirect
            res += getBranchCategory(inst);
            break;
        case C_IMAGE:
        case C_SYNC:
        case C_MISC:
        case C_GCN_MISC:
            break;
        default:
            assert(false);
            return "";
        }

        if (delim != '/') std::replace(res.begin(), res.end(), '/', delim);

        return res;
    }

    static string getCategoryTags(Inst inst, unsigned category)
    {
        using namespace Brig;

        assert(category < C_MAXID);
        string res = ',' + getCategoryName(inst, category, ',');

        if (isOperandCategory(inst, BRIG_KIND_OPERAND_WAVESIZE)) res += ",wavesize";

        if (isEquivCategory(inst)) res += ",equiv";

        unsigned type    = inst.type();
        unsigned srcType = getSrcType(inst);
        unsigned segment = getSegment(inst);
        unsigned opcode  = inst.opcode();

        if      (type == BRIG_TYPE_F16  || srcType == BRIG_TYPE_F16)  res += ",f16";
        else if (type == BRIG_TYPE_B128 || srcType == BRIG_TYPE_B128) res += ",b128";

        switch(opcode)
        {
        case BRIG_OPCODE_ACTIVELANEMASK:
        case BRIG_OPCODE_ACTIVELANEID:
        case BRIG_OPCODE_ACTIVELANESHUFFLE:
        case BRIG_OPCODE_ACTIVELANECOUNT:
            res += ",crosslane";
            break;

        default:
            break;
        }

        switch(segment)
        {
        case BRIG_SEGMENT_FLAT:
            res += ",flat";
            break;
        default:
            break;
        }

        return res;
    }

    static bool isEquivCategory(Inst inst)
    {
        using namespace Brig;
        switch (inst.opcode())
        {
        case BRIG_OPCODE_LD:
        case BRIG_OPCODE_ST:
        case BRIG_OPCODE_ATOMIC:
        case BRIG_OPCODE_ATOMICNORET:
        case BRIG_OPCODE_RDIMAGE:
        case BRIG_OPCODE_STIMAGE:
        case BRIG_OPCODE_LDIMAGE:
        case BRIG_OPCODE_GCNLD:
        case BRIG_OPCODE_GCNST:
        case BRIG_OPCODE_GCNATOMIC:
        case BRIG_OPCODE_GCNATOMICNORET:
            return true;
        default:
            return false;
        }
    }

    static bool isOperandCategory(Inst inst, unsigned kind)
    {
        for (int idx = 0; idx < inst.operands().size(); ++idx)
        {
            if (inst.operand(idx).brig()->kind == kind) return true;
        }
        return false;
    }

    static string getTypeCategory(Inst inst)
    {
        return string("/") + val2str(PROP_TYPE, getType(inst));
    }

    static string getPackedCategory(Inst inst)
    {
        return "/packed";
    }

    static string getVectorCategory(Inst inst)
    {
        for (int idx = 0; idx < inst.operands().size(); ++idx)
        {
            unsigned kind = inst.operand(idx).brig()->kind;
            if (kind == Brig::BRIG_KIND_OPERAND_OPERAND_LIST) return "/vector";
        }
        return "";
    }

    static string getBranchCategory(Inst inst)
    {
        for (int idx = 0; idx < inst.operands().size(); ++idx)
        {
            if (OperandReg reg = inst.operand(idx)) {
                if (getRegSize(reg) != 1) return "/indirect";
            }
        }
        return "/direct";
    }
    //==========================================================================
};

//==========================================================================
//==========================================================================
//==========================================================================

void TestGenNavigatorImpl::initBaseCategoryTab()
{
    assert(!instCategoryTab);
    unsigned size = getBaseCategoriesNum();
    instCategoryTab = new CategoryDesc[size];
    std::copy(baseCategories, baseCategories + size, instCategoryTab);
    std::sort(instCategoryTab, instCategoryTab + size);
}

unsigned TestGenNavigatorImpl::getBaseCategoryId(Inst inst)
{
    if (!instCategoryTab) initBaseCategoryTab();

    CategoryDesc sample = {0, inst.opcode()};
    unsigned size = getBaseCategoriesNum();
    CategoryDesc* res = std::lower_bound(instCategoryTab, instCategoryTab + size, sample);

    if (res >= instCategoryTab + size || res->instOpcode != inst.opcode()) 
    {
        ostringstream s;
        const char* name = HSAIL_ASM::opcode2str(inst.opcode());
        s << "Internal error: cannot get category for opcode " << inst.opcode() << " (" << (name? name : "UNKNOWN") << ')';
        throw TestGenError(s.str());
    } 
    else if (res->categoryId >= C_MAXID) 
    {
        ostringstream s;
        const char* name = HSAIL_ASM::opcode2str(inst.opcode());
        s << "Internal error: invalid category id for opcode " << inst.opcode() << " (" << (name? name : "UNKNOWN") << ')';
        throw TestGenError(s.str());
    }
    
    return res->categoryId;
}

//=============================================================================
// Interface definition
//=============================================================================

TestGenNavigator::TestGenNavigator()
{
    impl = new TestGenNavigatorImpl();
}

TestGenNavigator::~TestGenNavigator()
{
    delete impl;
}

bool TestGenNavigator::isOpcodeEnabled(unsigned opcode) const
{
    return impl->isOpcodeEnabled(opcode);
}

bool TestGenNavigator::startTest(Inst inst)
{
    return impl->startTest(inst);
}

string TestGenNavigator::getTestTags(unsigned testIdx, bool isFullDesc /*=true*/)
{
    return impl->getTestTags(testIdx, isFullDesc);
}

string TestGenNavigator::getRelTestPath()
{
    return impl->getRelTestPath();
}

//=============================================================================
//=============================================================================
//=============================================================================

} // namespace TESTGEN
